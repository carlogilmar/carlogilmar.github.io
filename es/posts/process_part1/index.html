














<!DOCTYPE html>
<html lang='es'><head>
    <meta charset="utf-8">
    <link rel="shortcut icon" href='/favicon.ico' type="image/x-icon">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Comprendiendo Procesos en la BEAM con Elixir 游댩 - 游꿛 Blog de @carlogilmar</title>

    

    

    
    <meta name="author" content="carlogilmar" />
    

    
        <meta property="og:title" content="Comprendiendo Procesos en la BEAM con Elixir 游댩" />
<meta property="og:description" content="Comprendiendo Procesos en la BEAM con Elixir  Este post es para todos los developers que quieren experimentar con Elixir, o bien que est치n en los primeros pasos con esta tecnolog칤a. Este tema requiere que tengas un conocimiento b치sico de Elixir y Erlang, al menos para comprender por qu칠 es importante dedicarle tiempo de calidad a este tema, porque es sin duda alguna uno de los conceptos centrales de la m치quina virtual de Erlang BEAM." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://carlogilmar.xyz/es/posts/process_part1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-20T00:00:00+00:00" />
<meta property="article:modified_time" content="2022-07-20T00:00:00+00:00" />


    

    
        <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Comprendiendo Procesos en la BEAM con Elixir 游댩"/>
<meta name="twitter:description" content="Comprendiendo Procesos en la BEAM con Elixir  Este post es para todos los developers que quieren experimentar con Elixir, o bien que est치n en los primeros pasos con esta tecnolog칤a. Este tema requiere que tengas un conocimiento b치sico de Elixir y Erlang, al menos para comprender por qu칠 es importante dedicarle tiempo de calidad a este tema, porque es sin duda alguna uno de los conceptos centrales de la m치quina virtual de Erlang BEAM."/>

    <link rel="stylesheet" href="/style.min.5297c96c59a52afaa5bcda4a6cedf3813081f64025c209b25b2ee6d0c8f74d462b625ad3404a92a14d7a51b4ec0a420337ae70f426fa4bce2d5f7459a3ca7274.css" integrity="sha512-UpfJbFmlKvqlvNpKbO3zgTCB9kAlwgmyWy7m0Mj3TUYrYlrTQEqSoU16UbTsCkIDN65w9Cb6S84tX3RZo8pydA==">



    <link rel="stylesheet" href="/lib/css/prism.min.6226f06f992e0d6166b0e26724efd050dcc381202a752892ba523b1b865de2ea5e427f8f7d10de682fc35d6e7444018247d1f25db5e1e3bab17068ce191c5886.css" integrity="sha512-Yibwb5kuDWFmsOJnJO/QUNzDgSAqdSiSulI7G4Zd4upeQn&#43;PfRDeaC/DXW50RAGCR9HyXbXh47qxcGjOGRxYhg==">


    
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CJXJL083W7"></script>
    <script>
        console.log("::Visual Partner-Ship::");
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-CJXJL083W7');
    </script>
    

    
    <script>
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.setAttribute("data-theme", "dark");
        } else {
            document.documentElement.setAttribute("data-theme", "light");
        }
    </script>
<script defer src="/js/header.7a2a109ec3782c57bad0332b662f8a5f41765505936b69868eb8bd5241de9daf23c388e82ca1831f6d09935013dcb9f71bfa7face3975880c1076028b7b0a6e1.js" integrity="sha512-eioQnsN4LFe60DMrZi&#43;KX0F2VQWTa2mGjri9UkHena8jw4joLKGDH20Jk1AT3Ln3G/p/rOOXWIDBB2Aot7Cm4Q=="></script>



    <script defer src="/js/zooming.fc76b730bcba24949cb337c58c5e935f727dbea8418e918e3b1794f0707d130aadf4ead341e9305a2c6045f7bc66700d73cc5c7f5d8f6ae2c7631e095f4e18ae.js" integrity="sha512-/Ha3MLy6JJScszfFjF6TX3J9vqhBjpGOOxeU8HB9Ewqt9OrTQekwWixgRfe8ZnANc8xcf12PauLHYx4JX04Yrg=="></script>







    
        

        
        

        
        
            
        

        <script defer src="/js/prism.3113e52d215fde553c8747fb87544cc26ae5ab9b25e8ab7e7ab767824138bca8c0edb05a3c2d6dbcda075db565c7025817f6f6eea26a5d14c4e53397ae7748e2.js" integrity="sha512-MRPlLSFf3lU8h0f7h1RMwmrlq5sl6Kt&#43;erdngkE4vKjA7bBaPC1tvNoHXbVlxwJYF/b27qJqXRTE5TOXrndI4g==" data-manual></script>
    



    
    
    
    <script defer src="/js/search-es.64db908cde868e00f376c3c9f689195d9ce0ae2aa0899cc3c009c492c55778efcd4fe312f0130a6d436752744619102b1fc90777faf20d4a357803771b75dfee.js" integrity="sha512-ZNuQjN6GjgDzdsPJ9okZXZzgriqgiZzDwAnEksVXeO/NT&#43;MS8BMKbUNnUnRGGRArH8kHd/ryDUo1eAN3G3Xf7g=="></script>




</head>
<body>
        <main><header>
    <div class="brand">
        <div id="sidebar_btn">
            <svg id="menu_icon" width="26px" height="26px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></svg>
        </div>

        <div>
            <a href="/es/">@carlogilmar</a>
        </div>
    </div>

    <div class="toolbox">
        <div id="theme_tool">
            <svg id="dark_mode_btn" class="hidden toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-sun"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg></svg>
            <svg id="light_mode_btn" class="hidden toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-moon"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></svg>
        </div>

        
            <div id="search_tool">
                <svg id="search_btn" class="toolbox-btn" width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg></svg><div id="search_menu_wrapper" class="hidden">
    <div id="search_menu">
        <div id="search_menu_toolbar">
            <div id="search_menu_input_wrapper">
                <input id="search_menu_input" type="text" placeholder='Search Posts'>
            </div>
            <div id="search_menu_close_btn">
                <svg width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg></svg>
            </div>
        </div>
        <div id="search_menu_results">
        </div>
    </div>
</div>
</div>
        

        
            <div id="translation_tool" class="dropdown-wrapper pure-menu pure-menu-horizontal toolbox-btn">
                <ul class="pure-menu-list">
                    <li class="pure-menu-item pure-menu-has-children pure-menu-allow-hover">
                        <div class="dropdown-btn pure-menu-link">
                            <svg width="18px" height="18px" viewBox="0 0 24 24"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-globe"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg></svg>
                            <span class="dropdown-desc">Spanish</span>
                        </div>
                        <ul class="pure-menu-children">
                            
                            <li class="pure-menu-item">
                                <a href="https://carlogilmar.xyz/" class="pure-menu-link">English</a>
                            </li>
                            
                            <li class="pure-menu-item">
                                <a href="https://carlogilmar.xyz/es/" class="pure-menu-link">Spanish</a>
                            </li>
                            
                        </ul>
                    </li>
                </ul>
            </div>
        
    </div>
</header>
<nav id="navbar" class="pure-menu"><ul class="pure-menu-list"><li class="navbar-item pure-menu-item insection">
                    
                        <a href="/es/posts/" class="pure-menu-link">救넖잺 Contenido</a>
                    
                </li></ul>
</nav>
<div id="sidebar_canvas_overlay" class="hidden"></div>
<div id="sidebar" class="close">
    <ul><li>
                    <a href="/es/posts/">救넖잺 Contenido</a>
                </li></ul>
</div><div id="content" class="content-margin">
                
    
    <div class="collapsible-menu-wrapper"><div class="collapsible-menu-type"><span>Table of contents</span></div><div class="collapsible-menu">
        
            <nav id="TableOfContents">
  <ul>
    <li><a href="#por-qu칠-entender-los-procesos">쯇or qu칠 entender los procesos?</a></li>
    <li><a href="#qu칠-es-un-proceso-en-el-ecosistema-de-erlang">쯈u칠 es un proceso en el ecosistema de Erlang?</a></li>
    <li><a href="#anatom칤a-de-un-proceso">Anatom칤a de un Proceso</a></li>
    <li><a href="#ciclo-de-vida">Ciclo de Vida</a></li>
    <li><a href="#creaci칩n-de-un-proceso">Creaci칩n de un Proceso</a></li>
    <li><a href="#interacci칩n-entre-procesos-recepci칩n-de-mensajes">Interacci칩n entre Procesos: Recepci칩n de Mensajes</a></li>
    <li><a href="#mantener-un-proceso-activo">Mantener un Proceso Activo</a></li>
    <li><a href="#mantener-un-estado">Mantener un Estado</a></li>
    <li><a href="#d칩nde-est치n-los-procesos">쮻칩nde est치n los procesos?</a></li>
    <li><a href="#processes-everywhere">Processes Everywhere</a></li>
  </ul>
</nav>
        
    </div></div>



    <div class="content-margin">

<article >
    
    
        
        
    
    <p><img src="https://user-images.githubusercontent.com/17634377/180091201-272c9504-dfef-441c-86b6-96753ae81b9d.png" alt="image"></p>
<h1 id="comprendiendo-procesos-en-la-beam-con-elixir">Comprendiendo Procesos en la BEAM con Elixir</h1>
<blockquote>
<p>Este post es para todos los developers que quieren experimentar con Elixir, o bien que est치n en los primeros pasos con esta tecnolog칤a. Este tema requiere que tengas un conocimiento b치sico de Elixir y Erlang, al menos para comprender por qu칠 es importante dedicarle tiempo de calidad a este tema, porque es sin duda alguna uno de los conceptos centrales de la m치quina virtual de Erlang BEAM.</p>
</blockquote>
<p>Aunque Elixir es considerado un lenguaje de prop칩sito general, no es necesario que tengas que meterte con este tipo de temas al inicio. Pero si quieres conocer porqu칠 la BEAM y sus lenguajes son tan populares en el mundo de concurrencia y paralelismo, este post es para ayudarte a comprender c칩mo dise침ar software en el ecosistema de Erlang.</p>
<h2 id="por-qu칠-entender-los-procesos">쯇or qu칠 entender los procesos?</h2>
<p>Seguramente al buscar informaci칩n sobre <strong>Elixir</strong> encontrar치s grandes caracter칤sticas como: sistemas altamente escalables, tolerancia a fallos, sistemas concurrentes y distribuidos, etc. Pues bien, todas estas ventajas vienen directamente de la M치quina Virtual de Erlang (mejor conocida como <strong>BEAM Bj칬rn&rsquo;s Erlang Abstract Machine</strong>).</p>
<p>Elixir, de nuevo, es un lenguaje de prop칩sito general. Esto quiere decir que puedes aprender a usarlo mediante su paradigma funcional, resolver algunos problemas del d칤a a d칤a, y no tener que meterte con el tema de <strong>procesos</strong> si as칤 lo deseas. Pero precisamente entender los <strong>procesos</strong> es una gran forma de entender qu칠 es lo que hace a Elixir un lenguaje tan poderoso y c칩mo comenzar a aprovechar todas las ventajas de su ecosistema, mismas que lo hacen diferente de otros lenguajes y plataformas.</p>
<h2 id="qu칠-es-un-proceso-en-el-ecosistema-de-erlang">쯈u칠 es un proceso en el ecosistema de Erlang?</h2>
<blockquote>
<p>Un proceso es una entidad aislada donde ocurre la ejecuci칩n de c칩digo.</p>
</blockquote>
<p>Los <strong>procesos</strong> est치n en todos lados en cualquier sistema creado en la BEAM, podr칤as usar cualquier lenguaje como <strong>Erlang</strong>, <strong>Elixir</strong>, <strong>Gleam</strong> o b, y podr치s encontrar el mismo concepto. Por ejemplo la shell interactiva iex, o los patrones de OTP son ejemplos de <strong>procesos</strong>.</p>
<p>Los <strong>procesos</strong> son parte central para crear programas concurrentes y construir dise침os distribuidos y tolerantes a fallos. Aunque, como mencion칠 anteriormente, podr칤as solo escribir m칩dulos y funciones, y no tener que preocuparte de c칩mo funcionan hasta cierto punto.</p>
<p>Quienes est치n empezando a aprender <strong>Elixir</strong> seguramente hemos escuchado hablar de <strong>OTP &ldquo;The Open Telecom Platform&rdquo;</strong>, una serie de abstracciones que nos permite explotar las capacidaddes de la <strong>BEAM</strong>. Entender el tema de <strong>procesos</strong> es tambi칠n entender qu칠 pasa &ldquo;behind the scenes&rdquo; de estas abstracciones, esto te ayudar치 a comprender c칩mo aprovechar estas ventajas al momento de dise침ar alg칰n componente de software.</p>
<h2 id="anatom칤a-de-un-proceso">Anatom칤a de un Proceso</h2>
<p><img src="https://user-images.githubusercontent.com/17634377/180091218-d7668ea8-daf4-4564-98e1-39e9d536712e.png" alt="image"></p>
<p>Un <strong>proceso</strong> es una entidad aislada que permite la <strong>ejecuci칩n de c칩digo</strong>, es la base para dise침ar software y aprovechar las ventajas que brinda la BEAM.</p>
<p>Un <strong>proceso</strong>, a nivel de memoria, esta compuesto de <strong>cuatro bloques</strong> donde se guarda toda la informaci칩n que permite su ejecuci칩n:</p>
<ol>
<li><strong>Stack</strong>: almacena las variables locales.</li>
<li><strong>Heap</strong>: almacena estructuras de datos largas.</li>
<li><strong>Mailbox</strong>: guarda los mensajes recividos.</li>
<li><strong>Process Control Block</strong>: Permite hacer el tracking del estado interno del proceso.</li>
</ol>
<h2 id="ciclo-de-vida">Ciclo de Vida</h2>
<p><img src="https://user-images.githubusercontent.com/17634377/180091244-96a32a8f-7d8c-4b8c-ad91-37eae985e293.png" alt="image"></p>
<p>Podemos definir de momento el ciclo de vida de un <strong>proceso</strong> en las siguientes fases:</p>
<ol>
<li>Creaci칩n</li>
<li>Ejecuci칩n de c칩digo</li>
<li>Finalizaci칩n (<code>termination</code>)</li>
</ol>
<h2 id="creaci칩n-de-un-proceso">Creaci칩n de un Proceso</h2>
<p>La funci칩n <code>spawn</code> nos permite crear un proceso, solo necesitaremos pasarle una funci칩n que guardar치 el c칩digo que se va a ejecutar dentro del proceso.</p>
<p>Al crear un proceso, obtendremos un <code>process identifier</code> con el que podremos identificar nuestro proceso. Esto ser치 posible con functiones provistar por el m칩dulo <code>Process</code>.</p>
<p>Veamos un ejemplo en la <code>iex</code>:</p>
<ol>
<li>Se crea una funci칩n para imprimir un <code>string</code>. Esta ser치 el c칩digo a ejecutar dentro de un proceso.</li>
</ol>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">execute_fun = fn -&gt; IO.puts &quot;Hi! 救넖잺  I'm the process #{inspect(self())}.&quot; end
</code></pre>
<ol start="2">
<li><strong>Creaci칩n de un proceso:</strong> Invoca la funci칩n <code>spawn</code> con la funci칩n <code>execute_fun</code> como par치metro 칰nico. Esto crear치 un nuevo proceso y regresar치 un <code>PID</code>.</li>
</ol>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">pid = spawn(execute_fun)
</code></pre>
<ol start="3">
<li>
<p><strong>Ejecuci칩n de c칩digo:</strong> inmediatamente al crear el proceso, se ejecutar치 la funci칩n que recibi칩 como par치metro.</p>
</li>
<li>
<p><strong>Terminaci칩n:</strong> Despu칠s de la ejecuci칩n de c칩digo, el proceso terminar치 su ejecuci칩n. Para verificar esto puedes usar la funci칩n <code>Process.alive?/1</code> que te regresar치 un valor booleano para indicar si el proceso sigue vivo o no.</p>
</li>
</ol>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">Process.alive?(pid)
</code></pre>
<p><img src="https://user-images.githubusercontent.com/17634377/180091343-76cecd9f-d9bf-45fe-848b-ab7a405c8880.gif" alt="blogpost1"></p>
<h2 id="interacci칩n-entre-procesos-recepci칩n-de-mensajes">Interacci칩n entre Procesos: Recepci칩n de Mensajes</h2>
<p>Es com칰n entonces dise침ar c칩digo para ejecutarse dentro de un proceso de forma individual, as칤 es que ser치 com칰n tener que ejecutar diferentes funcionalidades en procesos por serapado que tendr치n que interactuar entre s칤 en alg칰n punto en el tiempo, para ello existen <strong>los mensajes.</strong></p>
<p>Un <strong>proceso</strong> es capaz de ejecutar c칩digo de forma aislada as칤 como de recibir mensajes provenientes de otros procesos. Los mensajes son la 칰nica forma de <strong>comunicarse entre ellos</strong>, estos se guardan en el <strong>mailbox</strong>, uno de los cuatro bloques de memoria que componen a un proceso.</p>
<p>Es importante aclarar que los mensajes recibidos o enviados son independientes del c칩digo que se ejecuta.</p>
<p>Para procesar los mensajes recibidos es necesario usar la sentencia <code>receive</code>. Mientras que podr치s enviar mensajes con la sentencia <code>send</code>. Para ello nos sirve el <code>Process Identifier</code>, pues es la forma de identificar cada proceso y poder comunicarse con 칠l. Veamos el siguiente ejemplo:</p>
<ol>
<li>Se crear치 una funci칩n dentro de un m칩dulo <code>MyProcess.awaiting_for_receive_messages/0</code> que implementar치 la sentencia <code>receive</code>. Esto nos ayudar치 a indicarle al proceso que ejecuta ciertas acciones al recibir cierto tipo de mensajes provenientes de otro proceso.</li>
</ol>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">defmodule MyProcess do
  def awaiting_for_receive_messages do
    IO.puts &quot;Process #{inspect(self())}, waiting to process a message!&quot;
    receive do
      &quot;Hi&quot; -&gt;
        IO.puts &quot;Hi from me&quot;
      &quot;Bye&quot; -&gt;
        IO.puts &quot;Bye, bye from me&quot;
      _ -&gt;
        IO.puts &quot;Processing something&quot;
    end
    IO.puts &quot;Process #{inspect(self())}, message processed. Terminating...&quot;
  end
end
</code></pre>
<p>Este c칩digo puedes copiar y pegar directamente sobre la <code>iEx</code>.</p>
<ol start="2">
<li><strong>Creaci칩n de un proceso:</strong> Tomaremos la funci칩n anterior para crear un nuevo proceso, esto har치
que la funci칩n <code>receive</code> se ejecute <code>solo al recibir un mensaje</code>, entonces terminar치 la ejecuci칩n
y terminar치. De lo contrario el proceso no morir치, mientras la sentencia <code>receive</code> espera a ejecutarse.</li>
</ol>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">pid = spawn(MyProcess, :awaiting_for_receive_messages, [])
</code></pre>
<ol start="3">
<li><strong>Env칤o de mensajes:</strong> Cabe se침alar que la <code>iEx</code> es un proceso en s칤, por lo que podemos enviar mensajes desde aqu칤 al proceso que acabamos de crear. Usaremos la sentencia <code>send</code>, enviaremos el <code>PID</code> del proceso al que le vamos a enviar el mensaje, y el segundo par치metro ser치 el contenido del mismo, que para este caso ser치 un string pero podr칤a ser otro dato.</li>
</ol>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">send(pid, &quot;Hi&quot;)
</code></pre>
<ol start="4">
<li>
<p><strong>Ejecuci칩n de c칩digo:</strong> Al recibir el mensaje, inmediatamente se ejecutar치 nuestra funci칩n con el <code>receive</code>.</p>
</li>
<li>
<p><strong>Terminaci칩n:</strong> Al recibir el mensaje y procesarlo, nuestro proceso habr치 concluido. 쯇ero y qu칠 pasa si queremos mantener ese proceso a칰n con vida?</p>
</li>
</ol>
<p><img src="https://user-images.githubusercontent.com/17634377/180094062-491064b8-7555-4a1b-a7da-1834bb4861f3.gif" alt="blogpost2"></p>
<h2 id="mantener-un-proceso-activo">Mantener un Proceso Activo</h2>
<p>En el ejemplo anterior, nuestro proceso terminar치 su vida al procesar el mensaje. Es posible que un proceso siga activo incluso despu칠s de procesar un mensaje, para ello podemos hacer uso de la recursividad para volver a invocar la funci칩n con el <code>receive</code>. Esto nos ayudar치 tambi칠n a poder conservar un estado, como lo veremos m치s adelante.</p>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">defmodule MyProcess do
  def awaiting_for_receive_messages do
    IO.puts &quot;Process #{inspect(self())}, waiting to process a message!&quot;
    receive do
      &quot;Hi&quot; -&gt;
        IO.puts &quot;Hi from me&quot;
        awaiting_for_receive_messages()
      &quot;Bye&quot; -&gt;
        IO.puts &quot;Bye, bye from me&quot;
        awaiting_for_receive_messages()
      _ -&gt;
        IO.puts &quot;Processing something&quot;
        awaiting_for_receive_messages()
    end
    IO.puts &quot;Process #{inspect(self())}, message processed. Terminating...&quot;
  end
end
</code></pre>
<h2 id="mantener-un-estado">Mantener un Estado</h2>
<p>Retomando el ejemplo anterior, es posible conservar un estado que puede ir transform치ndose. A continuaci칩n te muestro un ejemplo de c칩mo quedar칤a nuestro m칩dulo de ejemplo:</p>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">defmodule MyProcess do
  def awaiting_for_receive_messages(messages_received \\ []) do
    receive do
      &quot;Hi&quot; = msg -&gt;
        IO.puts &quot;Hi from me&quot;
        [msg|messages_received]
        |&gt; IO.inspect(label: &quot;MESSAGES RECEIVED: &quot;)
        |&gt; awaiting_for_receive_messages()

      &quot;Bye&quot; = msg -&gt;
        IO.puts &quot;Bye, bye from me&quot;
        [msg|messages_received]
        |&gt; IO.inspect(label: &quot;MESSAGES RECEIVED: &quot;)
        |&gt; awaiting_for_receive_messages()

      msg -&gt;
        IO.puts &quot;Processing something&quot;
        [msg|messages_received]
        |&gt; IO.inspect(label: &quot;MESSAGES RECEIVED: &quot;)
        |&gt; awaiting_for_receive_messages()
    end
  end
end
</code></pre>
<p>En este caso ahora nuestra funci칩n <code>awaiting_for_receive_messages</code> reciben una lista vac칤a donde guardaremos los mensajes recibidos.</p>
<ol>
<li>Creaci칩n del proceso: <code>pid = spawn(MyProcess, :awaiting_for_receive_messages, [])</code></li>
<li>Recepci칩n de un mensaje: <code>send(pid, &quot;Hi&quot;)</code> despu칠s de invocar esto, podemos verificar que el proceso siga activo.</li>
<li>Recepci칩n de m치s mensajes: podremos repetir el paso anterior muchas veces.</li>
</ol>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">iex(3)&gt; pid = spawn(MyProcess, :awaiting_for_receive_messages, [])
#PID&lt;0.132.0&gt;

iex(4)&gt; Process.alive?(pid)
true

iex(5)&gt; send(pid, &quot;Hi&quot;)
Hi from me
&quot;Hi&quot;
MESSAGES RECEIVED: : [&quot;Hi&quot;]


iex(6)&gt; send(pid, &quot;Bye&quot;)
Bye, bye from me
&quot;Bye&quot;
MESSAGES RECEIVED: : [&quot;Bye&quot;, &quot;Hi&quot;]


iex(7)&gt; send(pid, &quot;Heeeey!&quot;)
Processing something
&quot;Heeeey!&quot;
MESSAGES RECEIVED: : [&quot;Heeeey!&quot;, &quot;Bye&quot;, &quot;Hi&quot;]
</code></pre>
<h2 id="d칩nde-est치n-los-procesos">쮻칩nde est치n los procesos?</h2>
<p>Muy bien, si me acompa침aste hasta este punto hemos recorrido algunas nociones b치sicas sobre qu칠 es un proceso y c칩mo funciona. Si te preguntas d칩nde puedes ver hasta donde llegar con estas implementaciones te doy un gran spoiler: <code>processes everywhere</code>.</p>
<p>Veamos un ejemplo de Phoenix Live Views, este es un m칩dulo que tiene efecto sobre un template de html (no te preocupes por el nombre de las funciones):</p>
<pre  class="mc-prism hide language-text" ><code class="language-elixir">defmodule DemoWeb.ClockLive do
  use DemoWeb, :live_view

  def render(assigns) do
    ~H&quot;&quot;&quot;
    &lt;div&gt;
      &lt;h2&gt;It's &lt;%= NimbleStrftime.format(@date, &quot;%H:%M:%S&quot;) %&gt;&lt;/h2&gt;
      &lt;%= live_render(@socket, DemoWeb.ImageLive, id: &quot;image&quot;) %&gt;
    &lt;/div&gt;
    &quot;&quot;&quot;
  end

  def mount(_params, _session, socket) do
    if connected?(socket), do: Process.send_after(self(), :tick, 1000)

    {:ok, put_date(socket)}
  end

  def handle_info(:tick, socket) do
    Process.send_after(self(), :tick, 1000)
    {:noreply, put_date(socket)}
  end

  def handle_event(&quot;nav&quot;, _path, socket) do
    {:noreply, socket}
  end

  defp put_date(socket) do
    assign(socket, date: NaiveDateTime.local_now())
  end
end
</code></pre>
<p><img src="https://user-images.githubusercontent.com/17634377/180096050-b5a27195-ed76-45f7-8809-58715853f47b.png" alt="image"></p>
<p>No me gustar칤a entrar en mucho detalle con los Live Views, pero si contarte que este m칩dulo sirve para dos cosas, por un lado las funciones <code>render/1</code> y <code>mount/3</code> sirven para hacer el setup de la <code>Live View</code>, las funciones <code>handle_info</code> y <code>handle_event</code> permiten mantener activa la conexi칩n del socket y un estado interno 쯦e suena esto familiar? 춰Es un proceso! Un <code>Live View</code> es una abstracci칩n de OTP para crear un proceso.</p>
<h2 id="processes-everywhere">Processes Everywhere</h2>
<p>Entender c칩mo funcionan los procesos te dar치 mejores conceptos para entender c칩mo funciona el Ecosistema de Erlang y para dise침ar mejores programas. Muchas bibliotecas y proyectos escritos en Elixir usan estos conceptos, entonces la pr칩xima vez que uses alg칰n proyecto, piensa que probablemente estar치s usando abstracciones de procesos por debajo.</p>
<p>Si quieres conocer m치s de este tema te sugiero probar el c칩digo de ejemplo en este post, y buscar los apartados de procesos dentro de los libros de Elixir o Erlang. Probablemente tambi칠n la documentaci칩n de Erlang te dar치 a칰n m치s conceptos sobre este gran tema.</p>
<p>Muchas gracias por llegar hasta aqu칤, si quieres conocer m치s de este gran mundo puedes ver las opciones de training y las pr칩ximas charlas de la <a href="https://codebeamamerica.com/">Code Beam Am칠rica</a>.</p>

</article>
</div>


                
                    
                
            </div>
<footer>
    <article>Carlo Gilmar 仇벒잺 Rights Reserved 춸 2022</article>
</footer>

</main>
    </body>
</html>
