[{"content":"Comprendiendo Procesos en la BEAM con Elixir  Este post es para todos los developers que quieren experimentar con Elixir, o bien que están en los primeros pasos con esta tecnología. Este tema requiere que tengas un conocimiento básico de Elixir y Erlang, al menos para comprender por qué es importante dedicarle tiempo de calidad a este tema, porque es sin duda alguna uno de los conceptos centrales de la máquina virtual de Erlang BEAM.\n Aunque Elixir es considerado un lenguaje de propósito general, no es necesario que tengas que meterte con este tipo de temas al inicio. Pero si quieres conocer porqué la BEAM y sus lenguajes son tan populares en el mundo de concurrencia y paralelismo, este post es para ayudarte a comprender cómo diseñar software en el ecosistema de Erlang.\n¿Por qué entender los procesos? Seguramente al buscar información sobre Elixir encontrarás grandes características como: sistemas altamente escalables, tolerancia a fallos, sistemas concurrentes y distribuidos, etc. Pues bien, todas estas ventajas vienen directamente de la Máquina Virtual de Erlang (mejor conocida como BEAM Björn\u0026rsquo;s Erlang Abstract Machine).\nElixir, de nuevo, es un lenguaje de propósito general. Esto quiere decir que puedes aprender a usarlo mediante su paradigma funcional, resolver algunos problemas del día a día, y no tener que meterte con el tema de procesos si así lo deseas. Pero precisamente entender los procesos es una gran forma de entender qué es lo que hace a Elixir un lenguaje tan poderoso y cómo comenzar a aprovechar todas las ventajas de su ecosistema, mismas que lo hacen diferente de otros lenguajes y plataformas.\n¿Qué es un proceso en el ecosistema de Erlang?  Un proceso es una entidad aislada donde ocurre la ejecución de código.\n Los procesos están en todos lados en cualquier sistema creado en la BEAM, podrías usar cualquier lenguaje como Erlang, Elixir, Gleam o b, y podrás encontrar el mismo concepto. Por ejemplo la shell interactiva iex, o los patrones de OTP son ejemplos de procesos.\nLos procesos son parte central para crear programas concurrentes y construir diseños distribuidos y tolerantes a fallos. Aunque, como mencioné anteriormente, podrías solo escribir módulos y funciones, y no tener que preocuparte de cómo funcionan hasta cierto punto.\nQuienes están empezando a aprender Elixir seguramente hemos escuchado hablar de OTP \u0026ldquo;The Open Telecom Platform\u0026rdquo;, una serie de abstracciones que nos permite explotar las capacidaddes de la BEAM. Entender el tema de procesos es también entender qué pasa \u0026ldquo;behind the scenes\u0026rdquo; de estas abstracciones, esto te ayudará a comprender cómo aprovechar estas ventajas al momento de diseñar algún componente de software.\nAnatomía de un Proceso Un proceso es una entidad aislada que permite la ejecución de código, es la base para diseñar software y aprovechar las ventajas que brinda la BEAM.\nUn proceso, a nivel de memoria, esta compuesto de cuatro bloques donde se guarda toda la información que permite su ejecución:\n Stack: almacena las variables locales. Heap: almacena estructuras de datos largas. Mailbox: guarda los mensajes recividos. Process Control Block: Permite hacer el tracking del estado interno del proceso.  Ciclo de Vida Podemos definir de momento el ciclo de vida de un proceso en las siguientes fases:\n Creación Ejecución de código Finalización (termination)  Creación de un Proceso La función spawn nos permite crear un proceso, solo necesitaremos pasarle una función que guardará el código que se va a ejecutar dentro del proceso.\nAl crear un proceso, obtendremos un process identifier con el que podremos identificar nuestro proceso. Esto será posible con functiones provistar por el módulo Process.\nVeamos un ejemplo en la iex:\n Se crea una función para imprimir un string. Esta será el código a ejecutar dentro de un proceso.  execute_fun = fn -\u0026gt; IO.puts \u0026quot;Hi! ⭐️ I'm the process #{inspect(self())}.\u0026quot; end  Creación de un proceso: Invoca la función spawn con la función execute_fun como parámetro único. Esto creará un nuevo proceso y regresará un PID.  pid = spawn(execute_fun)   Ejecución de código: inmediatamente al crear el proceso, se ejecutará la función que recibió como parámetro.\n  Terminación: Después de la ejecución de código, el proceso terminará su ejecución. Para verificar esto puedes usar la función Process.alive?/1 que te regresará un valor booleano para indicar si el proceso sigue vivo o no.\n  Process.alive?(pid)  Interacción entre Procesos: Recepción de Mensajes Es común entonces diseñar código para ejecutarse dentro de un proceso de forma individual, así es que será común tener que ejecutar diferentes funcionalidades en procesos por serapado que tendrán que interactuar entre sí en algún punto en el tiempo, para ello existen los mensajes.\nUn proceso es capaz de ejecutar código de forma aislada así como de recibir mensajes provenientes de otros procesos. Los mensajes son la única forma de comunicarse entre ellos, estos se guardan en el mailbox, uno de los cuatro bloques de memoria que componen a un proceso.\nEs importante aclarar que los mensajes recibidos o enviados son independientes del código que se ejecuta.\nPara procesar los mensajes recibidos es necesario usar la sentencia receive. Mientras que podrás enviar mensajes con la sentencia send. Para ello nos sirve el Process Identifier, pues es la forma de identificar cada proceso y poder comunicarse con él. Veamos el siguiente ejemplo:\n Se creará una función dentro de un módulo MyProcess.awaiting_for_receive_messages/0 que implementará la sentencia receive. Esto nos ayudará a indicarle al proceso que ejecuta ciertas acciones al recibir cierto tipo de mensajes provenientes de otro proceso.  defmodule MyProcess do def awaiting_for_receive_messages do IO.puts \u0026quot;Process #{inspect(self())}, waiting to process a message!\u0026quot; receive do \u0026quot;Hi\u0026quot; -\u0026gt; IO.puts \u0026quot;Hi from me\u0026quot; \u0026quot;Bye\u0026quot; -\u0026gt; IO.puts \u0026quot;Bye, bye from me\u0026quot; _ -\u0026gt; IO.puts \u0026quot;Processing something\u0026quot; end IO.puts \u0026quot;Process #{inspect(self())}, message processed. Terminating...\u0026quot; end end  Este código puedes copiar y pegar directamente sobre la iEx.\nCreación de un proceso: Tomaremos la función anterior para crear un nuevo proceso, esto hará que la función receive se ejecute solo al recibir un mensaje, entonces terminará la ejecución y terminará. De lo contrario el proceso no morirá, mientras la sentencia receive espera a ejecutarse.  pid = spawn(MyProcess, :awaiting_for_receive_messages, [])  Envío de mensajes: Cabe señalar que la iEx es un proceso en sí, por lo que podemos enviar mensajes desde aquí al proceso que acabamos de crear. Usaremos la sentencia send, enviaremos el PID del proceso al que le vamos a enviar el mensaje, y el segundo parámetro será el contenido del mismo, que para este caso será un string pero podría ser otro dato.  send(pid, \u0026quot;Hi\u0026quot;)   Ejecución de código: Al recibir el mensaje, inmediatamente se ejecutará nuestra función con el receive.\n  Terminación: Al recibir el mensaje y procesarlo, nuestro proceso habrá concluido. ¿Pero y qué pasa si queremos mantener ese proceso aún con vida?\n  Mantener un Proceso Activo En el ejemplo anterior, nuestro proceso terminará su vida al procesar el mensaje. Es posible que un proceso siga activo incluso después de procesar un mensaje, para ello podemos hacer uso de la recursividad para volver a invocar la función con el receive. Esto nos ayudará también a poder conservar un estado, como lo veremos más adelante.\ndefmodule MyProcess do def awaiting_for_receive_messages do IO.puts \u0026quot;Process #{inspect(self())}, waiting to process a message!\u0026quot; receive do \u0026quot;Hi\u0026quot; -\u0026gt; IO.puts \u0026quot;Hi from me\u0026quot; awaiting_for_receive_messages() \u0026quot;Bye\u0026quot; -\u0026gt; IO.puts \u0026quot;Bye, bye from me\u0026quot; awaiting_for_receive_messages() _ -\u0026gt; IO.puts \u0026quot;Processing something\u0026quot; awaiting_for_receive_messages() end IO.puts \u0026quot;Process #{inspect(self())}, message processed. Terminating...\u0026quot; end end  Mantener un Estado Retomando el ejemplo anterior, es posible conservar un estado que puede ir transformándose. A continuación te muestro un ejemplo de cómo quedaría nuestro módulo de ejemplo:\ndefmodule MyProcess do def awaiting_for_receive_messages(messages_received \\\\ []) do receive do \u0026quot;Hi\u0026quot; = msg -\u0026gt; IO.puts \u0026quot;Hi from me\u0026quot; [msg|messages_received] |\u0026gt; IO.inspect(label: \u0026quot;MESSAGES RECEIVED: \u0026quot;) |\u0026gt; awaiting_for_receive_messages() \u0026quot;Bye\u0026quot; = msg -\u0026gt; IO.puts \u0026quot;Bye, bye from me\u0026quot; [msg|messages_received] |\u0026gt; IO.inspect(label: \u0026quot;MESSAGES RECEIVED: \u0026quot;) |\u0026gt; awaiting_for_receive_messages() msg -\u0026gt; IO.puts \u0026quot;Processing something\u0026quot; [msg|messages_received] |\u0026gt; IO.inspect(label: \u0026quot;MESSAGES RECEIVED: \u0026quot;) |\u0026gt; awaiting_for_receive_messages() end end end  En este caso ahora nuestra función awaiting_for_receive_messages reciben una lista vacía donde guardaremos los mensajes recibidos.\n Creación del proceso: pid = spawn(MyProcess, :awaiting_for_receive_messages, []) Recepción de un mensaje: send(pid, \u0026quot;Hi\u0026quot;) después de invocar esto, podemos verificar que el proceso siga activo. Recepción de más mensajes: podremos repetir el paso anterior muchas veces.  iex(3)\u0026gt; pid = spawn(MyProcess, :awaiting_for_receive_messages, []) #PID\u0026lt;0.132.0\u0026gt; iex(4)\u0026gt; Process.alive?(pid) true iex(5)\u0026gt; send(pid, \u0026quot;Hi\u0026quot;) Hi from me \u0026quot;Hi\u0026quot; MESSAGES RECEIVED: : [\u0026quot;Hi\u0026quot;] iex(6)\u0026gt; send(pid, \u0026quot;Bye\u0026quot;) Bye, bye from me \u0026quot;Bye\u0026quot; MESSAGES RECEIVED: : [\u0026quot;Bye\u0026quot;, \u0026quot;Hi\u0026quot;] iex(7)\u0026gt; send(pid, \u0026quot;Heeeey!\u0026quot;) Processing something \u0026quot;Heeeey!\u0026quot; MESSAGES RECEIVED: : [\u0026quot;Heeeey!\u0026quot;, \u0026quot;Bye\u0026quot;, \u0026quot;Hi\u0026quot;]  ¿Dónde están los procesos? Muy bien, si me acompañaste hasta este punto hemos recorrido algunas nociones básicas sobre qué es un proceso y cómo funciona. Si te preguntas dónde puedes ver hasta donde llegar con estas implementaciones te doy un gran spoiler: processes everywhere.\nVeamos un ejemplo de Phoenix Live Views, este es un módulo que tiene efecto sobre un template de html (no te preocupes por el nombre de las funciones):\ndefmodule DemoWeb.ClockLive do use DemoWeb, :live_view def render(assigns) do ~H\u0026quot;\u0026quot;\u0026quot; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;It's \u0026lt;%= NimbleStrftime.format(@date, \u0026quot;%H:%M:%S\u0026quot;) %\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;%= live_render(@socket, DemoWeb.ImageLive, id: \u0026quot;image\u0026quot;) %\u0026gt; \u0026lt;/div\u0026gt; \u0026quot;\u0026quot;\u0026quot; end def mount(_params, _session, socket) do if connected?(socket), do: Process.send_after(self(), :tick, 1000) {:ok, put_date(socket)} end def handle_info(:tick, socket) do Process.send_after(self(), :tick, 1000) {:noreply, put_date(socket)} end def handle_event(\u0026quot;nav\u0026quot;, _path, socket) do {:noreply, socket} end defp put_date(socket) do assign(socket, date: NaiveDateTime.local_now()) end end  No me gustaría entrar en mucho detalle con los Live Views, pero si contarte que este módulo sirve para dos cosas, por un lado las funciones render/1 y mount/3 sirven para hacer el setup de la Live View, las funciones handle_info y handle_event permiten mantener activa la conexión del socket y un estado interno ¿te suena esto familiar? ¡Es un proceso! Un Live View es una abstracción de OTP para crear un proceso.\nProcesses Everywhere Entender cómo funcionan los procesos te dará mejores conceptos para entender cómo funciona el Ecosistema de Erlang y para diseñar mejores programas. Muchas bibliotecas y proyectos escritos en Elixir usan estos conceptos, entonces la próxima vez que uses algún proyecto, piensa que probablemente estarás usando abstracciones de procesos por debajo.\nSi quieres conocer más de este tema te sugiero probar el código de ejemplo en este post, y buscar los apartados de procesos dentro de los libros de Elixir o Erlang. Probablemente también la documentación de Erlang te dará aún más conceptos sobre este gran tema.\nMuchas gracias por llegar hasta aquí, si quieres conocer más de este gran mundo puedes ver las opciones de training y las próximas charlas de la Code Beam América.\n","permalink":"https://carlogilmar.xyz/es/posts/process_part1/","title":"Comprendiendo Procesos en la BEAM con Elixir 🔮"},{"content":"Recientemente he estado conociendo el lenguaje Elixir, un lenguaje que aprovecha la máquina virtual de Erlang, una plataforma conocida por soportar sistemas en baja latencia, sistemas distribuidos y tolerantes a fallas.\nPara familiarizarme con el lenguaje he optado por resolver algunos ejercicios, un par de ellos son el Fizz Buzz y Guess My Number.\nFizz Buzz // My Fizzbuzz Solution in Swift for i in 1...50 { if i%5==0 \u0026amp;\u0026amp; i%3==0 { print(\u0026quot;Fizzbuzz 🍻 \u0026quot;) } else if i%5 == 0{ print(\u0026quot;Buzz\u0026quot;) } else if i%3==0{ print(\u0026quot;Fizz\u0026quot;) } else{ print(\u0026quot;\\(i)\u0026quot;) } }  Normalmente suelo resolver este ejercicio con una iteración, y el siempre confiable y útil IF, sin embargo, Elixir al ser un lenguaje funcional obliga a la implementación de otra solución bajo términos funcionales, aquí el primer reto.\nLa forma natural en la pienso el cómo resolver esto es:\n Obtener una lista de números para iterar Evaluar cada número en los posibles casos del FizzBuzz  Primer Acercamiento con Elixir El primer alcance que pude lograr fue el obtener una lista de números a partir de un número, el número mayor en esta lista.\ndefmodule Learning do def makeListUntil(1), do: [1] def makeListUntil(n), do: makeListUntil(n-1) ++ [ n ] end  La principal dificultad de esto fue el concebir la idea del tener más de una función que se llama a sí misma, y la idea de que tener casos específicos de esta función como el caso de def makeListUntil(1), do: [1] necesario para tener un tope en las llamadas recursivas al invocar la función. En lo personal resultó complicado e interesante el hecho de ir armando una lista de esta forma.\nEsto me ayudó para implementar la distinción de casos del fizz buzz, para lo cuál realice varios casos de una misma función:\ndef eval(0), do: [0] def eval(elem) when rem(elem,5)==0 and rem(elem,3)==0, do: :fizzbuzz def eval(elem) when rem(elem,3)==0, do: [:fizz] def eval(elem) when rem(elem,5)==0, do: [:buzz] def eval(elem), do: elem  Al pasar un solo número con esto podía distinguir si era un fizz, un buzz, un fizz buzz, o cero.\nEl siguiente pasó fue implementar la lista, de modo que al pasar un número N, obtuviera una lista desde 0 hasta N, con la implementación de fizz buzz.\nEste paso resultó también el que más tiempo me llevó, probablemente debido a ser uno de mis primeros acercamientos al lenguaje.\ndefmodule Learning do def eval(0), do: [0] def eval(elem) when rem(elem,5)==0 and rem(elem,3)==0, do: eval(elem-1) ++[:fizzbuzz] def eval(elem) when rem(elem,3)==0, do: eval(elem-1) ++ [:fizz] def eval(elem) when rem(elem,5)==0, do: eval(elem-1) ++ [:buzz] def eval(elem), do: eval(elem-1) ++ [elem] end  Esta única función recibe un número, el cuál es evaluado por casos según el fizz buzz, e inicia una lista, enviando el número menos uno a la misma función. En la ejecución podemos ver que el número pasa de forma descendente por las funciones escritas.\nErlang/OTP 20 [erts-9.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace] Compiling 2 files (.ex) Interactive Elixir (1.6.1) - press Ctrl+C to exit (type h() ENTER for help) iex(1)\u0026gt; Learning.eval 10 [0, 1, 2, :fizz, 4, :buzz, :fizz, 7, 8, :fizz, :buzz] iex(2)\u0026gt; Learning.eval 11 [0, 1, 2, :fizz, 4, :buzz, :fizz, 7, 8, :fizz, :buzz, 11] iex(3)\u0026gt; Learning.eval 20 [0, 1, 2, :fizz, 4, :buzz, :fizz, 7, 8, :fizz, :buzz, 11, :fizz, 13, 14, :fizzbuzz, 16, 17, :fizz, 19, :buzz] iex(4)\u0026gt; Learning.eval 1 [0, 1] iex(5)\u0026gt;  Segundo Acercamiento Ya con ayuda de @neodevelop, pudimos encontrar una segunda solución a este ejercicio usando más elementos del lenguaje.\nEste acercamiento trataba directamente a una lista de números, a los cuales se aplicaba una función, que debería retornar una función con la solución correcta. Aquí hicimos uso de las tuplas, para llamar a una función fb_categorize que nos regresaría un elemento con el que iríamos formando la lista con la solución.\ndef applyFizzbuzz([], fb_list), do: fb_list def applyFizzbuzz([head|tail], fb_list) do item = fb_categorize({ rem(head,3)==0, rem(head,5)==0, {head} }) applyFizzbuzz( tail, fb_list ++ [item] ) end  Para ello nuestra función fb_categorize al recibir una tupla de elementos booleanos podríamos implementarla tantas veces como combinaciones necesarias.\n def fb_categorize({true, false, _}), do: :fizz def fb_categorize({false, true, _}), do: :buzz def fb_categorize({true, true, _}), do: :fizzbuzz def fb_categorize({_, _, number}), do: number  Finalmente para concluir nuestro ejercicio hicimos uso del pipe de elixir para primero crear una lista de número a partir de un número, y luego aplicar el fizz buzz, y hacer nuestro código más legible:\n def fizzbuzz(number) do number |\u0026gt; makeListUntil |\u0026gt; applyFizzbuzz([]) end  Erlang/OTP 20 [erts-9.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:10] [hipe] [kernel-poll:false] [dtrace] Interactive Elixir (1.6.1) - press Ctrl+C to exit (type h() ENTER for help) iex(1)\u0026gt; Learning.fizzbuzz 20 [ {1}, {2}, :fizz, {4}, :buzz, :fizz, {7}, {8}, :fizz, :buzz, {11}, :fizz, {13}, {14}, :fizzbuzz, {16}, {17}, :fizz, {19}, :buzz ] iex(2)\u0026gt;  Al comprender estos elementos del lenguaje pude resolver otro ejercicio “Guess my number”, del cuál platicaré en otro post.\nGracias por leer.\n","permalink":"https://carlogilmar.xyz/es/posts/elixir_first/","title":"Hello Elixir!"},{"content":"El sábado pasado tuve la oportunidad de asistir al primer Github Field Day en México, organizado por los Github Campus Experts locales.\nEl evento trató de reunir a estudiantes y sus comunidades tecnológicas en un día dedicado a platicar debatir, intercambiar ideas, y coincidir. A pesar de que en la Ciudad de México existen muchas comunidades tecnológicas, esta fue la oportunidad de conocer las comunidades tecnológicas mayormente estudiantiles; tanto estudiantes de la UNAM, del IPN, como del Tec. de Monterrey, entre muchas otras, y de temas diversos que van desde los Google Developer Groups, hasta la promoción de las mujeres en la tecnología.\nEsta vez junto a @alee_rguez pudimos realizar el registro gráfico de la apertura del evento, para después unirnos y participar en la desconferencia. Creémos que un registro gráfico de un evento siempre deja una sensación agradable, por lo que propusimos la idea y fue aceptada. Aquí el registro:\nLa desconferencia La desconferencia inició después de un concurso de octocats que los participantes diseñamos. Y trató básicamente de temas que, voluntariamente, fuimos proponiendo. El lugar donde estábamos se dividió en dos, que serían nuestras aulas, y dió inicio la agenda recién formada.\nLa mayoría de las charlas trataron de temas sobre comunidades, ¿cómo conseguir apoyos para mi comunidad?, ¿como trascender mi comunidad?, ¿Qué hacer contra la burocracia? Es agradable conocer tan cerca las ideas predominantes en algunos estudiantes universitarios. Si pudiera llegar a una conclusión es que existen muy buenos deseos entre los participantes de este evento, personas motivadas y con ganas de apoyar a sus compañeros a descubrir, en conjunto, este mundo apasionante del software.\nDespués de haber escuchado varios de los principales problemas que los muchachos tenían eran relacionados a sus escuelas, desde problemas para conseguir espacios, para conseguir asistentes, para conseguir ponentes, me queda muy claro que para avanzar, tanto en el aspecto individual como colectivo, es necesario superar la escuela y su burocracia.\nLa emotividad en el discurso de la mayoría de las personas que estaban platicando sus experiencias de pronto iba descubriendo un sentimiento compartido: la necesidad de una fraternidad universitaria, una fraternindad más allá de los colores y de los renombres, más allá de las tribus y comparaciones, una fraternidad tecnológica. ¿Aún dudan que el software nos va a transformar como personas?\nSin embargo no me quedó del todo claro cómo hacerlo, rescato lo valioso de las propuestas, pero quizá hace falta un compromiso mayor, que posiblemente el tiempo puede ir construyendo.\nCreo que al final todos nos fuimos contentos de conocer y ubicar a las personas que seguramente en un futuro estarán promoviendo las principales comunidades de tecnología.\nMi propuesta en la desconferencia: no venía preparado, pero\u0026hellip; Como ya había realizado el Módulo 16 del entrenamiento de Github Campus Experts, consideré conveniente proponer la charla de Git: Procesos y herramientas para mejorar a las personas y sus interacciones.\nAnteriormente ya había tenido la oportunidad de probarla en el último Agile Open.\nBásicamente la charla tiene por objetivo platicar sobre los principales usos de git y los beneficios de usarlo con plataformas como github. Al parecer pocos usan esta herramienta, por lo que creo que fue un buen tema para promover su uso, y hacer incapié en los principales beneficios tanto técnicos (controlador de versiones, manejo de features, manejo del tiempo en un proyecto), como colaborativos (flujos de trabajo, estadísticas de desempeño, exploración del flujo de un proyecto).\nLa organización Creo muy sugerente la participación de los Github Campus Experts @jpflores9, @imonsh, @FerroRodolfo, y @luisejrobles como mediadores durante la desconferencia.\nFue importante su labor ya que durante las charlas intentaron crear el dialogo e intercambio de ideas, intentar que el evento no fuera unidireccional. ¡Gracias!\nGithub Field Day Me queda clara la importancia de un evento así: reunir a estudiantes universitarios y provocar que interaccionen.\nÓjala tengamos más eventos así, que tanto hacen falta, y que poco a poco se vayan convirtiendo en ese catalizador que necesita la comunidad estudiantil en general.\nA través del software nos transformamos como comunidad. Gracias por leer.\n","permalink":"https://carlogilmar.xyz/es/posts/github/","title":"Github Field Day México"},{"content":"El evento Tuve la oportunidad de ir a mi tercer Open Space organizado por la comunidad de Ágiles México. Esta vez me sentí muy diferente del primer Open Space del año pasado, cuando apenas comenzaba a comprender todo esto de la agilidad y el software desde la perspectiva de un alumno universitario, esta vez lo hago desde la perspectiva de un desarrollador de software.\nEl Open Space es una dinámica muy propia de comunidades ágiles, y muy única, es un espacio donde los asistentes nos organizamos para crear la agenda del día con pláticas y talleres propuestos al inicio del día. Con esto es posible crear la agenda para tener al rededor de 7-8 charlas simultáneas por hora.\nEn el primer Open Space, allá por Mayo del 2016, asistí a muchas charlas, me ofrecí para hablar acerca de las comunidades tecnológicas y me animé a dibujar el registro gráfico de una charla. En el segundo Open Space me animé a dar una charla sobre Cultura Ágil, a llevar a mi novia, quien se animó a solicitar una charla sobre agilidad fuera del software, y ambos realizamos algunos registros gráficos. Esta vez decidí usar más la ley de los dos pies para encontrar los lugares más interesantes durante este Open Space. Me animé de nuevo a proponer una charla, a realizar los registros gráficos de un par de temas, y a ser asistente a otras más.\nMi charla propuesta Esta vez aproveché el espacio para proponer la charla: “Git: procesos y herramientas para mejorar personas y sus interacciones”.\nComo parte del entrenamiento de Github Campus Experts se solicita preparar una charla, y está era la oportunidad de darla por vez primera y obtener todo el feedback posible.\nEl tema central es el uso de Git en el desarrollo de software y como su uso individual y en equipo, exige que la comunicación aumente, el objetivo es dar a conocer la herramienta y a grandes rasgos los beneficios que puede dar. Para mi Git es el ejemplo de un software que transforma por si mismo si es que se quiere aprovechar todo lo que ofrece.\nDecidí proponer este tema porque me parece que llega un punto donde el software y las herramientas quedan muy olvidadas. El manifiesto ágil menciona: “personas e interacciones sobre procesos y herramientas”, pero también al final dice “aunque valoramos los elementos de la derecha, valoramos más los de la izquierda”. Esto de ninguna forma significa que no sean importantes. Y creo fielmente que la agilidad es fruto de las interacciones que se han dado en el software, por esto mismo pienso importante llegar a una visión más íntegra donde no perdamos de vista lo prioritario sin dejar de tomar en cuenta lo importante, es decir, si, las personas y sus interacciones son muy importantes, para mi es la piedra angular de muchas cosas, pero sin olvidar que hacemos software, y que no son dos cosas por aparte.\nAfortunadamente las personas que entraron formaron un diálogo muy interesante que me permitió saber cómo puedo mejorar esta charla.\nAunque los nervios me atraparon por momentos y olvidé muchas cosas que quería platicar, logré hablar de otras como por ejemplo del blog de la comunidad de Ágiles Mexico que junto a un compañero montamos en un proyecto en Github y Github Pages.\nLas charlas que dibujé Esta vez dibujé un par de charlas: “Human Agile” y “Mejorando las habilidades de un equipo de desarrollo”.\nCasi todo el evento, excepto en las sesiones donde dibujé, me la pasé de salón en salón escuchando un poco de los temas que se estaban dando.\nAl inicio hubo una sesión que me llamó mucho la atención. Trataba sobre Driven Desing Domain, un tema técnico, y por lo tanto a su vez era la charla menos concurrida de ese horario. Lo valioso fue ver las interacciones que se generaron con las personas que estaban ahí, pues de una charla bidireccional, donde hay un expositor y un público que escucha, pasó a un diálogo entre los asistentes quienes hacían preguntas, daban puntos de vista, cuestionaban puntos de vista ajenos, e inclusive usaron el pizarrón para construir un esquema comunitario. Pero la parte más importante estuvo en lo que se dijo, me agradó mucho ver a personas que hacen software cuestionándose por sentido común si realmente ágil es algo que pueda ayudar en el software, y logrando reivindicar ágil fuera de los soft skills. Creo que en esencia aquí estuvo mucho del porque nació ágil: buscando mejores formas de hacer software.\nOtra charla que me gustó bastante fue de @itzareyesmx quien hablo de cómo en su empresa mejoraron las habilidades “soft”, “personales”, y “técnicas” del equipo de desarrollo partiendo desde el hecho de saber que ellos desarrollan software y sin perder el foco en esto. Me parece que hoy más que nunca es importante este tipo de charlas, porque pareciera de momento que ágil comienza a divorciarse del software cuando ágil nació por el software. Más que buscar cómo aplicar ágil en otros campos, me parece que la obligación de quienes estamos desarrollando software es precisamente buscar mejores formas de hacerlo.\nOtra parte importante del evento son las interacciones y diálogos que se producen en los pasillos, en el jardín, en la hora de la comida, pues ahí es donde el diálogo se vuelve más espontáneo y más fluido.\nHumildad para aceptarte un continuo aprendiz de software Un día de muchos aprendizajes. Mi palabra que resumió mi día, que mas me impactó y que más se me quedó fue: software.\nEstamos descubriendo formas mejores de desarrollar\u2028software tanto por nuestra propia experiencia como\u2028ayudando a terceros, a través de este trabajo he aprendido a valorar la agilidad y sus principios. ","permalink":"https://carlogilmar.xyz/es/posts/openspace/","title":"#AgilesMX17 Reseña"},{"content":"Este mes de Octubre el equipo de Making Devs fue invitado a un evento en la FES Acatlán de la UNAM, donde festejaban el aniversario de la Licenciatura en Matemáticas Aplicadas y Computación. En representación del equipo asistí junto a @cggg88jorge, @vane_emily, en una charla sobre Cultura Ágil para estudiantes de los primeros semestres de esa misma carrera.\nPlaticar de cultura siempre es un tema desafiante. Por lo regular al hablar de tecnología y software es de esperarse tocar temas técnicos, es por eso que resulta ser una charla interesante y curiosa. ¿Cultura en el software? ¿Cultura en un equipo de trabajo?\nLa Charla Pues bien, decidimos platicar sobre el Manifiesto Ágil y un poco del contexto que lo rodea. Uno de los puntos más importantes a dejar en claro era la importancia de los valores de colaboración en grupos de personas. Tuvimos un buen número de asistentes, así que decidimos pedir la ayuda de algunos de ellos para realizar actividades, y tener público participante y público observador, la mayor parte del tiempo estuvimos moviéndonos de un lado a otro en lugar de quedarnos en el asiento que nos habían asignado.\nLas dinámicas que realizamos fueron relacionadas a los valores y sensaciones de la colaboración en equipo. En lo particular es algo que no deja de asombrarme, ver en interacción a un grupo de personas y observar sus movimientos, sus palabras, sus gestos y sus actos instintivos permiten una dinámica que ellos recrean en ese momento exponiendo muchos rasgos culturales que en ellos prevalecen.\nPor mi parte hablé de lo necesario que es comunicarnos entre personas, y de cómo esto puede potenciar las habilidades de un equipo. Estoy complemente seguro que la tecnología es un campo que re-evoluciona, re-inventa y transforma vidas, por lo que también invité a los estudiantes a motivarse, a ser curiosos, a descubrir sus pasiones a través de la tecnología, y a descubrir por cuenta propia lo apasionante e inmenso que es el mundo del software.\nMi compañero Jorge platicó sobre su experiencia en los ambientes laborales donde ha estado, y de cómo han implementado lo \u0026ldquo;ágil\u0026rdquo; a través de prácticas que nada tienen que ver con lo que realmente es ágil.\nPor su parte, mi compañera Vanessa platicó sobre su experiencia en Making Devs y el contraste con el ambiente que le tocó vivir en su antiguo lugar de trabajo.\nConcluimos recomendando que la próxima vez que escucharan algo relacionado a ágil (scrum, kanban, metodología, técnica, lenguajes, diseño, arquitectura, programación, requerimientos, equipo, dinámica) pensarán en si en ello existían estos valores y sensaciones, y se preguntarán el por qué: ¡realidad reflexiva!\nEstudiantes de la UNAM Una de las situaciones que me llamó la atención fue la participación de los estudiantes de la escuela en sus eventos de tecnología pues uno de ellos fue quien nos extendió la invitación, eso habla muy bien de esta universidad y sus estudiantes.\nComparación entre UNAM e IPN Ya anteriormente tuvimos la oportunidad de platicar del mismo tema y hacer las mismas dinámicas en el IPN, en dos carreras: Ingeniería en Informática, y Licenciatura en Ciencias de la Informática, y logramos ver muchas diferencias.\nPor un lado los muchachos de ingeniería se mostraron muy poco participativos en las dinámicas, tardaron bastante en realizarlas y mostraron mucha timidez; por ejemplo no pudimos escuchar muchas opiniones debido a que no querían hablar. Los chicos de Ciencias de la Informática se mostraron por otra parte muy participativos, daban su punto de vista y se atrevían a hacer preguntas, en las dinámicas estuvieron activos y aunque les costó trabajo entenderlas después de un tiempo lograron realizarlas. Y esta vez con los chicos de la UNAM pasó algo curioso, pues al principio mostraron timidez en las actividades, sin embargo han sido el único grupo que ha realizado las dinámicas correctamente y sin tantos problemas, se mostraron más despiertos y expresivos en la parte de preguntas.\nLecciones Aprendidas Es la primera vez que soy expositor en un auditorio de universidad, aunque ya había dado temas en salones de clase, el estar en un auditorio me cambió la situación y me provocó otro tipo de nervios. La charla de Cultura Ágil como ya mencioné es un tema desafiante, pues se tocan temas delicados y profundos a la vez. Las actividades y la interacción con el público siempre es necesaria para dejar en claro los principales puntos, y en cada sesión se pueden refinar.\nMuchísimas gracias a la UNAM por su invitación.\nAquí pueden consultar la presentación de la charla: Presentación de Cultura Ágil\nGracias por leer.\n","permalink":"https://carlogilmar.xyz/es/posts/unam-cultura/","title":"Charla en UNAM FES Acatlán"},{"content":"Mi primera clase en UPIICSA: una breve reseña Recientemente estoy cursando el último semestre de mi carrera; platicando con mi profesor de la materia de Dot Net, así es en UPIICSA tenemos una asignatura llamada así, llegamos al acuerdo de que podría tomar una clase a la semana para compartir con la clase todo lo que he aprendido como desarrollador de software.\nEra la primera vez que me dejaban una clase a la semana a mi cargo, de inmediato intenté responderme las preguntas de ¿que será útil que comparta con mis compañeros? Entonces pensé que sería bueno platicar de ciertos temas:\nRound 1 Cultura Ágil La primer clase que tuvimos charlamos sobre valores y cultura. Intenté dejar claro la importancia de esto mismo en un equipo de trabajo. Realizamos algunas actividades y comentamos sobre las diferentes percepciones que tenemos.\nRound 2 Aprendiendo Git En agosto de este mismo año (2017) publiqué un post en un grupo de Facebook preguntando por personas interesadas en aprender Git, ya que quería practicar mi inglés. Hubo muchos interesados, entonces armamos un grupo de Slack donde platicamos. La dinámica fue sencilla: yo escribía una guía para que ellos practicaran. Afortunadamente al menos una persona, un estudiante universitario de la India, logró seguirla y aprender cómo hacer un commit.\nDespués de tomar algunos minutos para platicar sobre las ventajas del uso de una shell de comandos para operar tu Sistema Operativo, y del uso de un editor de texto (claro que platique maravillas sobre VIM), pasamos al tema del versionamiento de software a través de GIT.\nAsí entonces retomando ideas del proyecto anterior, continué con mostrarles lo básico de git: cómo instalarlo, como agregar tu usuario, las ares de Git y los comandos básicos.\nLo bueno: el feedback Me emociona mucho el compartir lo que he aprendido con alguien más, por lo que este proyecto me entusiasmó demasiado.\nEnseñar significa un reto muy interesante: comunicar efectivamente algún conocimiento de tal forma que alguien lo pueda comprender.\nEnseñar implica rectificar lo que ya has aprendido y refinarlo.\nLo malo: las sensaciones que promoví Lamentablemente esto no es de mucho interés para la mayoría mis compañeros, pues es ningún momento pude despertar su interés completo.\nProbablemente el material que preparé fue demasiado técnico para enseñarlo, por lo que puede que haya sido un factor más por el que casi nadie se interesó. Inclusive mi propio profesor me hizo el comentario de que hablaba cosas muy técnicas y que no podía entender.\nDespués de varias sesiones intentando ver cómo realizar un commit, me pidieron seguir con otro tema diferente.\nLo mejor Un compañero se acercó para platicarme que no entendía lo que era un PULL en Git, dado que aunque usaba Git en su trabajo no entendía muy bien su uso, platicamos y al final tuvo una idea de lo que era.\nLecciones Aprendidas Esta es la primera clase que tengo a cargo, si se le puede llamar así, y sin duda alguna me queda claro que no es sencillo, que el estar en un aula de clases también implica relacionarte con los asistentes, romper la barrera entre quien enseña y aprender, romper la barrera de la indiferencia y despertar el interés y curiosidad.\nPor otra parte también me queda aprendido que debo encontrar una forma más intuitiva, sencilla, y simple de explicar Git. Aunque no pude transmitir lo que quería me quedó con estos aprendizajes.\n","permalink":"https://carlogilmar.xyz/es/posts/mi-primera-clase/","title":"Mi Primera Clase en UPIICSA: Una breve reseña"},{"content":"Primera Parte Inicializando git y agregando usuario Primer Commit Segundo Commit Viendo diferencias y deshaciendo cambios Regresando a un commit Enviando a repositorio remoto ","permalink":"https://carlogilmar.xyz/es/posts/git-resume/","title":"Resumen del Taller básico de Git"},{"content":"Hace poco más de un año asistí a un Meetup de la comunidad de Ágiles México. Era el segundo al que asistía , en esta ocasión el tema fue sobre Facilitación Gráfica por @fperezguajardo.\nA partir de ese momento descubrí lo importante que era para mí explorar más a fondo la creatividad por medio de dibujos, formas y colores. Siempre he sido una persona que raya libros con plumones, a la que le gusta llenar los cuadernos con rayones, claro, a pesar de no ser un gran dibujante. Lo que siempre he tenido claro es que: si lo puedo dibujar, lo puedo entender.\nEntonces me comencén a usar más y más los dibujos como una herramienta de uso cotidiano. Cuando inicié a desarrollar software se convirtió en una herramienta mucho más útil y práctica.\nMe sorprendía mucho ver la habilidad para hacer registros gráficos o bien para llevar a cabo facilitaciones gráficas, porque resulta una tarea muy compleja y que requiere del uso de muchos sentidos, como lo es el oído para poder escuchar detenidamente y fijar la atención fuera del ruido que pueda existir en el momento, se necesita del tacto y de una capacidad de concentración para ir plasmando las ideas principales, darles tamaño, forma, ubicación y consistencia.\nQuiero compartir tres experiencias que he tenido en relación a esto:\nCurso de Agilidad Fui el encargado de realizar los registros gráficos de un curso de agilidad en Making Devs. Está era la primera vez que me animaba a hacer algo así.\nAl inicio éramos yo, plumones y un pliego en blanco. La primera gran dificultad que encontré para esta actividad fue: ¿por donde comienzo? ¿Por el título, por el banner, con una plantilla?\nLo más lógico que me pareció en ese momento fue iniciar con el título en el centro, e ir acomodando información en sentido de las manecillas del reloj. Sin embargo tuve problemas como el no poder abarcar todo el espacio y dejar huecos horribles.\nA medida que iba haciendo lamina tras lamina noté lo mucho que me costaba hacer dibujos al momento y la facilidad para ir reteniendo ideas en palabras. Así que decidí fijar mi rutina de trabajo en escribir aquellas ideas que me parecían las más importantes, para después aplicar color y hacer algunos dibujos.\nLa aplicación del color fue otro elemento importante, llegue a la conclusión de que muchos colores en una lamina provocaban que se perdiera el énfasis que podía dar a través del color, así que preferí usar 1 color, en diferentes tonos ñ para escribir títulos e ideas, por ejemplo verde en tono oscuro y claro, y 2 colores más: negro y rojo. Con el color negro me gusta hacer algunos dibujos, mientras que el rojo me ayuda a dar énfasis a ciertas ideas.\nEn este curso tuvo un ritmo muy tranquilo, donde por momentos había mucha información valiosa para escribir, pero que también tenía momentos (por ejemplo, cuando realizaban dinámicas grupales) donde me permitían tomarme tiempo para dar algunos detalles.\nAquí algunas láminas: Desarrollo ágil\n En esta lamina no pude encontrar una forma de darle estructura más uniforme a las ideas, por lo que mi impresión es que todo se ve revuelto, además de que los colores no ayudan.\n Equipos ágiles\n En esta lámina no logré disponer del espacio.\n Registros gráficos en reuniones Ya con un poquito más de experiencia, @alee_rguez y yo decidimos experimentar un poco más (queremos preparar un taller para nuestra escuela). Así que nos volvimos voluntarios para cubrir los registros gráficos de algunos eventos, con la intención de aportar una evidencia visual de lo más relevante de la reunión, el primero de ellos fue Hackers And Founders.\nEra la primera vez que hacíamos algo así, aunque sabíamos que era difícil, el nerviosismo de escribir y dibujar enfrente de muchas personas se hizo presente.\nLa primera reunión en Hackers And Founders, tuvimos un reto mucho mayor a lo que esperábamos: 7 ponencias de 10 minutos. ¡Pum!\nAunque no estabamos preparados para poder cubrir todas las charlas, decidimos ir dividiendo los registros visuales, de modo que cada uno hiciera 3/4 láminas y tuviera 20 minutos para poder terminarla. Sin embargo el flujo de ideas fue tremendo, las ponentes (todas mujeres) aprovecharon su tiempo para decir ideas valiosas e importantes, todo tan rápido que era muy difícil estar atento escuchando y dibujando al mismo tiempo.\nAl ver el poco tiempo que teníamos, y sabiendo que no podríamos hacer láminas demasiado elaboradas y retacadas de contenido, decidimos realizar registros que plasmaran sólo algunas de las ideas principales, acompañados de algunos dibujos y figuras, que dieran una impresión general de la charla.\nAl final logramos hacer los 7 registros gráficos, y terminamos fundidos.\nLos retos ahora además de decidir la forma de ir cubriendo el espacio de la lamina, fueron desde elegir un título de la charla (algunas no tenían definido uno), el poco tiempo que tuvimos, el trabajo en equipo para poder hacer todas las láminas, y el énfasis en las ideas principales.\nDesde entonces participamos en una reunión de Epic Queen, y en otra más de Hackers And Founders con @hmCuesta sobre Machine Learning.\nRegistros gráficos en hackatón #comoniña El siguiente reto fue en el hackatón organizado por Epic Queen, al cuál fuimos invitados a participar como voluntarios para cubrir los registros gráficos de las chicas concursantes.\nPara nosotros el reto consistía en realizar una lámina que plasmara los proyectos en los cuáles trabajaban. Sin embargo al llegar al lugar nos dimos cuenta que ¡eran cerca de 100 chicas, y alrededor de 25 equipos!\nTeníamos que organizarnos lo mejor posible para hacer un registro visual en poco tiempo, y que permitiera resumir la idea principal. Así que comenzamos recorriendo el lugar y pidiendo a las chicas unos escasos minutos para que nos contarán sus ideas. Ahí logré notar que aunque ya era un poco tarde, el hecho de preguntar por el proyecto ayudaba a que el equipo coordinara sus ideas y juntas vieran sus ideas en una lámina. Llegaba a ver ciertos detalles como que algunas tardaban en describir el proyecto, o que entre todas se preguntaban sobre qué idea habían elegido como la mejor, etcétera.\nCreo que en este punto pasamos de hacer registros gráficos a la facilitación gráfica en cierta medida, aunque creo también que quizá con un poco más de organización hubieramos podido proponer ejercicios de facilitación gráfica para ayudar a las chicas a concretar sus ideas y proyectos.\nAl final logramos hacer alrededor de 16 láminas.\nSatisfecho por la experiencia Después de estas tres experiencias puedo decir que he aprendido mucho, pues se han tratado de experiencias totalmente diferentes.\nY sin duda alguna es una actividad que disfruto hacer y practicar.\nAdicionalmente he comenzado a leer el libro GameStorming para ahondar más en las dinámicas grupales y el uso de dibujos.\nAdemás hemos comenzado un tablero en trello donde estamos recopilando todos los registros visuales que vamos realizando, pueden verlo en:\nTablero Registros Visuales\nGracias por leer hasta acá.\n","permalink":"https://carlogilmar.xyz/es/posts/registros-graficos/","title":"De la práctica en los Registros Visuales"},{"content":"Esta historia tiene comienzo hace unas semanas, justo cuando me convertí en un participante del curso de principios de agilidad de Making Devs impartido por @neodevelop en DS Indigo.\nAdemás de realizar los registros visuales del curso, fui un testigo y observardor de las dinámicas y expresiones que iban surgiendo en los participantes, actividad que en lo personal creo que es muy laboriosa, pues observar requiere de prestar atención y aprender a mirar aquellos detalles que pueden parecer poco importantes pero que revelan muchas cosas bajo una mirada más a detalle y precisa.\nEl curso duró varios días, y estuvo lleno de dinámicas, reflexiones, y entendimientos.\nFueron días de muchísimo aprendizaje, que me han llevado a tener un proceso que cerró con su primera iteración, y que les pĺatico enseguida.\nAquí algunos registros visuales Un elemento esencial: sentir para aprender Al final del curso quedé con muchas ganas de replicar y comprobar todas las actividades de las que había sido testigo. Creo que los principios y valores son la parte inicial del camino para comprender la agilidad en el software, y creo también en que para entender esta importancia es necesario verlo, sentirlo, comprobarlo, por ello la necesidad de buscar formas creativas de hacerle ver esto a las personas.\nCierre de una iteración en mi proceso de aprendizaje Curiosamente en mi clase en Upiicsa de Calidad y Normalización de Software, un grupo de compañeros tocaron los temas de Scrum, TSP, PSP, entre otros. Mi profesor y yo acordamos que, aprovechando la ocasión, me cedería una clase de dos horas para un taller de Scrum que dejaría más claro para qué funciona. Aquí es donde se me presentó la oportunidad perfecta para replicar lo que había aprendido.\nTaller de Scrum para mi clase Después de mucho pensar, decidí que para presentar Scrum, primero tendría que presentar algunas cosas. Para ello preparé una presentación muy básica con los elementos generales del framework, utilizando dibujos hechos por mí para una presentación de Scrum que dí meses atrás en otra clase.\nLa táctica erá simple: hacer énfasis en los principios de scrum.\nPara ello, antes de presentar esta información pensé que sería buena idea hacer 4 dinámicas muy simples.\nPrimer hit  La primera actividad consistió en hacer que todo el grupo formará un equipo y pasará fichas. Cada ficha que pasaba por todos los integrantes signifaba un punto. Ellos debían estimar cuantos puntos podrían hacer en un par de minutos.\n Primer momento: ¡Fatal! En cinco minutos que tuvieron para organizarse, no pudieron levantarse y hablar entre ellos. Esperaron a que una persona propusiera una idea y la compartiera casi persona por persona. No convencidos de la idea, y sin haber entendido del todo, comenzaron a levantarse y a formar un circulo. No pudieron mantener un conteo exacto de las fichas que iban pasando, y claro, no sabían si habían pasado por todos para obtener el punto.\nSegundo momento: No tan fatal como el anterior. Cuando escucharon que tendrían minutos para volver a organizarse noté que un par de personas más se animaron a hablar con fuerza, y a proponer ideas para una mejor distribución. Aunque siguieron con el mismo problema de no saber si una ficha pasaba por todos, esta vez se notó una mejor coordinación.\nAl termino de la segunda vez platicamos sobre los principales problemas que vimos: COMUNICACIÓN, COLABORACIÓN, PLANEACIÓN. Aproveche para pedirles que anotarán las primeras impresiones que les dejaba la actividad.\nSegundo hit  La segunda actividad fue la máquina de movimientos: un compañero iniciaba un movimiento con un sonido, al que debía seguirle otro compañero, hasta formar una cadena de movimientos y sonidos.\n Esta actividad es muy interesante y divertida. Al inicio pedí voluntarios para que se fueran sumando, pero al ver que nadie quería ponerse al frente, mover las manos y hacer un sonido, pedí que algunos participaran. Ahí encontré la primera dificultad al tratar de incitarlos a unirse.\nUna vez teniendo a varios compañeros formando una máquina de movimientos, me acerqué al primer compañero para pedirle que hiciera el movimiento muy lento. Miramos atentamente que sucedía, y me volvía a acercar a él para pedirle que ahora lo hiciera muy lento.\nEs para mi muy interesante esto porque desde el inicio comienzan a proyectarse emociones en cada participante y en cada observador, desde personas que se extrañan de ver algo así, hasta miradas burlonas.\nLo interesante fue ver que cuando alguien iba lento, todos se alentaban. Y cuando el primer movimiento fue rápido, todos comenzaron a acelerar.\nTercer hit  Formaron un círculo/ovalo formado por bancas, enfrente de cada banca había alguien. Una persona del círculo salía, desocupando un lugar. El objetivo consistía en que esa persona debía tomar un lugar vacío, mientras los demás debían evitar que tomará ese lugar\n Fue una dinámica rápida, y un poco difícil por las sillas. Resultó un momento donde todos los compañeros con lugar se movían, sin dejar oportunidad de tomar el lugar vacío.\nCuarto Hit  Ocho voluntarios pasaron al frente y tomaron una imagen, mientras se formaban ocho equipos. Un miembro de cada equipo debía ir con un voluntario con imagen, escuchar una descripción sin verla, e ir con el equipo a describir la imagen. El equipo debía replicar ladescripción de la imagen.\n Esta actividad fue la última, y personalmente creo que es muy reveladora en muchos sentidos, además de muy divertida.\n¿Que ocurrió? Al seleccionar las imagenes, traté de que fueran muy complejas y con muchos detalles. Al inicio noté que estaba costando trabajo describir la imagen, eso era una buena señal para mí. Acepto que me divertí viendo las caras de quienes escuchaban atentamente, hubo quien intentaba hasta dibujar un boceto de la imagen.\nLuego estas personas regresaron a sus equipos para describirles la imagen, y poder replicarla.\n¡BOOM!\nAl terminar el tiempo que les establecí (todas las actividades fueron bajo cronómetro), llegó el momento de las demos.\nComparamos la imagen con el dibujo del equipo y para mi fortuna salió como esperaba que saliera: la mayoría de las imágenes no se parecían, detalles importantes de la imagen no estaban, detalles inexistentes aparecieron por que \u0026ldquo;eran una buena idea del equipo de dibujo\u0026rdquo;, y también hubo quien dibujo algo similar a lo que la persona con la imagen logró describir sin que fuera exactamente la imagen.\nCreo que es aquí donde los participantes pueden ver muchos de los problemas que implica la labor de desarrollar software, además de que las presentaciones son un momento de diversión y risas constantes.\nDurante las demos alguien dijo que eran muchos detalles para entenderlos todos, a lo que respondí que podía haber regresado con la persona que tenía la imagen. -¿Apocó eso se podía?- me dijó. ¿Por qué no preguntaron?- contesté.\nRecolectando ideas Una vez terminadas todas las actividades, lanzé dos preguntas en general: ¿Qué problemas han visto en estas actividades? y ¿Qué proponen para solucionarlos?\nPara mí es muy importante que las personas tengan un momento de reflexión, y que puedan comenzar a ver por sí mismas todos los inconvenientes que se pudieron ver, y también es importante ponerlos en un escenario donde ellos deban proponer soluciones con base en lo que conocen o en lo que creen.\nAlguien comenzó a hablar sobre los problemas de comunicación, de colaboración, de participación, de coordinación, de monitoreo, entre otros. Y las soluciones que propusieron fueron limitadas a un \u0026ldquo;hay que hablarnos más\u0026rdquo;, \u0026ldquo;hay que tener más iniciativa\u0026rdquo;, etc.\nAhora sí, les presentó Scrum Una vez concluídas las actividades, después de haber recapitulando todos los problemas que vieron, y haber escuchado las soluciones, ahora sí les presenté el framework de Scrum.\n¿Qué noté? Lo que pocas veces me había sucedido: varios participantes escuchaban con atención.\nLa táctica fue la siguiente: vamos a hacer actividades para que vean estos problemas, y una vez que detectaron dichos problemas, puedo presentarles algo que trata con ello.\nCreo que fue una forma más eficaz de provocar que vieran los principios ágiles y a Scrum como algo útil al tratar problemas de este tipo. Claro que también hice énfasis en que todo lo que habían visto el día de hoy era sólo la introducción del primer principio ágil: personas e interacciones sobre procesos y herramienas.\nFue agradable ver a varios compañeros compartiendo dudas y comentarios sobre la agilidad y el desarrollo de software.\nAl final recomendé unos cuantos libros como:\n \u0026ldquo;SBOK Guide\u0026rdquo;\n  \u0026ldquo;Becoming Agile\u0026rdquo; Greg Smith \u0026amp; Ahmed Sidky\n  \u0026ldquo;Agile!: The Good, the Hype and the Ugly\u0026rdquo; Bertrand Meyer\n Y también los invité a la comunidad de Ágiles México si quierían aprender más.\nApuntes de los participantes Al inicio pedí que anotarán las ideas que fueran teniendo sobre las actividades, estas son algunas de las hojas que me entregaron mis compañeros:\nAl Final Creo que muchos al final pudieron ver la importancia de la agilidad al momento de colaborar en equipo, así como muchos también se fueron con dudas respecto al cómo sucede eso al momento de hacer software.\nEl cronometrar las actividades me ayudó a no perder demasiado tiempo.\nSin duda alguna este taller me sirvió para poner en práctica todo lo que aprendí anteriormente, y espero me llevé a mejorar.\nMuchísimas gracias si llegaron hasta acá.\nSaludos, Carlo.\n","permalink":"https://carlogilmar.xyz/es/posts/workshop-scrum/","title":"Workshop de Scrum en Upiicsa"},{"content":"Este sábado 21 de Enero sucedió el Agile Day en la Inventoteca de la ciudad de Puebla, y ahora les comparto un poco de lo que sucedió.\nEl programa fue el siguiente:\n1.- Cultura ágil por José Juan R. Zuñiga\n2.- Agilidad: Perspectiva de un desarrollador por Edgar Hernández\n3.- Taller de User Story Mapping por Víctor García\n4.- Taller de Scrum con Legos por Rox Muñoz\nTuve la oportunidad de participar en la primera charla dando un testimonio de cómo me he ido desenvolviendo en este ámbito. Sin embargo también pude participar en las dos primeras charlas colaborando con Facilitación Gráfica, que también aprendí en la comunidad de Ágiles México gracias a Fernando Pérez Guajardo @fperezguajardo, aquí relato mejor el inicio de esa experiencia que sin duda alguna me ha trasnformado: Mi Primer Proyecto Ágil\nCultura Ágil Esta fue la primer charla por @neodevelop, con la cual se inauguró el evento, y tocó uno de los pilares esenciales de la agilidad: los valores y la cultura.\nAl inicio hicimos dos dinámicas muy entretenidas y divertidas, que seguramente hicieron romper el hielo entre los asistentes, quienes estuvieron muy participativos.\nLa primera dinámica fue la Máquina de colaboración\n Consistió en que un participante comenzaba un movimiento, como pasando algo de un lado a otro, al que se unía otro para seguir el movimiento, hasta que la gran mayoría estuviera participando.\n La segunda dinámica se trató del Juego de Monedas, que a mi personalmente me sorprende más cada que lo veo.\n Cinco personas se ponen en línea, o de forma circular, con muchas monedas sobre la mesa, el primero debe voltear todas las monedas y pasarlas al siguiente, quien hará lo mismo, esto es la primera ronda. La segunda ronda se hará lo mismo con la variante de que cuando el primer participante volteé cinco monedas, las pasará al siguiente mientras él termina de voltear las demás. En la tercera y última ronda ahora volteaba una moneda y la pasaba. Los resultados fueron muy sorprendentes.\n Al final de la charla Jorge, Gama, y yo pudimos compartir nuestro testimonio, cómo incorporar una cultura ágil en nuestras vidas no ha hecho mejorar en muchos aspectos.\nAquí la facilitación gráfica que hice durante la charla.\nAgilidad: Perspectiva de un desarrollador En esta charla @edgarh2e nos platicó sobre los retos que vivió como desarrollador dentro de diferentes ámbitos, y cómo al conocer el mundo ágil pudo lograr enfocar sus enfuerzos en tener una mejora continua que le permitiera proponer nuevas y mejores ideas dentro del contexto que le tocará.\nNos platicó de los manifiestos Ágil, y del Artesano de Software, de cómo SCRUM se ha convertido en una especie de esperanza prometida dentro de las empresas que esperan la solución a todos sus problemas. Nos compartió un poco sobre el Modelo Kano, el Modern Agile, y las características de un profesional del software.\nLas referencias bibliográficas:\n Clean Code, Robert Martin\n  Working Effectively with Legacy Code. Michael Feathers\n Aquí la facilitación gráfica que hice durante esta charla:\nTaller User Story Mapping Durante este taller impartido por @idvicman pudimos aprender sobre Scrum y cómo se define un producto de software de forma ágil.\nEl objetivo del taller era desarrollar una plataforma de ELearning, para lo cuál iniciamos obteniendo los roles, primero de forma individual, hasta discutir en equipo y obtener los roles.\nAsí poco a poco fuimos desmenuzando las funcionalidades de la plataforma a diseñar, fuimos comentando y discutiendo cuáles eran más y menos importantes, las priorizamos, y las acomodamos de acuerdo al rol que debía tener, para que al final decidieramos cuál sería nuestro producto mínimo viable, y las siguientes entregas.\nTaller de Scrum con Legos Este taller impartido por @jeri4queen inició con una explicación sobre los rasgos generales de Scrum y cómo funciona.\nLa dinámica era simple, pero con un grado de complejidad en el fondo: diseñar un monstruo mediante cuatro sprints.\nCada equipo de trabajo contó con un Product Owner, quien daba los requerimientos en forma de Historias de Usuario al inicio de cada Sprint.\nSiempre es curioso ver cómo se desenvuelve cada participante de los equipos, y cómo logran llevar a cabo la planeación, el desarrollo, la entrega, y la retrospectiva.\nUn día de mucha agilidad Sin duda alguna el evento fue entretenido, las dinámicas de las primeras charlas nos divirtieron muchísimo, y creo que a varios les agradó las facilitaciones gráficas que me aventé. Los talleres nos hicieron participar mucho, las paredes terminaron llenas de hojas de rotafolio de nuestros productos, y el scrum con legos siempre es muy dinámico.\nY como pude expresar cuando dí mi testimonio: es importante estar en un lugar donde te sientas feliz y puedas ver a personas felices; y eso es algo que he notado en eventos como estos, personas emocionadas, participantes animados, y mucha colaboración para poder lograr un evento como estos.\nGracias por leer.\n@carlogilmar\n","permalink":"https://carlogilmar.xyz/es/posts/agiledaypuebla/","title":"Agile Day Puebla"},{"content":"Hace poco recordaba sobre todo lo que he aprendido el los últimos seis meses como aprendiz de programador, entre estas reflexiones pensaba sobre los elementos básicos que debía tener cualquier persona que se quisiera dedicar enserio al desarrollo profesional de software.\nCreo que el tema da para muchísimos temas, pero uno fundamental del que quiero hablar es el de las herramientas. En este momento creo que la elección de tus herramientas de trabajo definen también el ritmo de tú trabajo.\nYa no estamos en la época de las cavernas, hoy en día contamos con herramientas para el desarrollo de software al alcance de nuestras manos que nos hacen más útiles, productivos y sin duda felices.\n¿Qué herramientas considero esenciales y básicas para el desarrollador?\nAquí una ilustración hecha por mí:\n1.- Un Sistema Operativo No sé si esto cuente exactamente como una herramienta, pero creo que es necesario hacer mención de que siempre es necesario conocer tu S.O. muy bien así sea un Windows, un linux (yo uso Ubuntu), o Unix (larga vida a Apple y sus MAC). Es indispensable para mí al día de hoy conocer cómo operarlo, así como tener prendida la llama de la curiosidad por querer conocer siempre un poquito más.\n2.- Un editor de texto No fue hasta que lo ví con mis propios ojos que esto si hace la diferencia a la hora de codear, pues las funciones que te provea pueden darte mucha rapidez, y eso siempre es grato. Sublime Text por ejemplo tiene varias cosas interesantes como el multi-selector, y tiene un padre coloreado de sintaxis; sin embargo yo he elegido aprender VIM y tenerlo como mi arma de fuego principal, estoy encantado con él, a pesar de que fue complicado agarrarle el ritmo, pero con práctica pronto entrené a mis manos a manipular las combinaciones de teclas, y todas las funcionalidades que tiene me facilitan escribir, y me hace muy feliz usarlo. Fue una inversión que rindió muchos frutos.\n3.- Shell\u0026rsquo;s Decía que había que conocer bien el S.O., pues creo que también es necesario saber operar la línea de comando, la primera razón de muchísimas: velocidad. Con un simple cd, ls, cd.. puedo entrar a una carpeta y ver lo que hay dentro sin necesidad de abrir el administrador de archivos, doble click, esperar, que cargue y muestre los archivos. Y a través del uso de la Shell podemos exprimir nuestro S.O. Hasta ahora he probado ZShell y FISH Shell, ambas ofrecen la posibilidad de exprimir más nuestra línea de comando a través de temas y plugins, como los de git. Adicionalmente podemos instalar el complemento de TMUX para poder sacar aún mucho más a nuestra consola sea cual sea. A mi en lo personal me ha gustado más usar FISH Shell por la función del auto completado, además de que me permite cambiarle el promt y poner emojis.\n4.- Controlador de Versiones No hay duda, GIT es una herramienta que uso todos los días hasta para ir al baño. No puedo ver mi vida sin él. Al inicio es bastante complicado poder entenderle, puesto que necesita de dedicación, esfuerzo y estudio para poder ir entendiendo de qué trata. Sin embargo es una inversión obligatoria, y que brinda muchos beneficios, desde versionar código, hasta trabajar en equipo.\nA grandes rasgos para mí son las principales herramientas básicas para iniciar a desarrollar software, y claro que existen muchas más.\nAquí comparto un pequeño tablero donde anotaba en pequeñas tarjetas de colores cada nuevo conocimiento, por muy pequeño que fuera, que ví las primeras diez semanas como desarrollador de software, y me queda muy claro algo: ¡Existe un mundo de muchas cosas por conocer!\n","permalink":"https://carlogilmar.xyz/es/posts/programmer/","title":"Las herramientas básicas de un desarrollador de Software"},{"content":" Para iniciar\u0026hellip; Recientemente he descubierto el gran y amplio mundo que implica el uso de la herramienta Git para proyectos de software.\nAún buscando entre tutoriales, y libros, el primer acercamiento es algo similar a lanzarse a un mar sin saber nadar, por ello mismo lo primero que hice fue hacer uso de la Facilitación Gráfica para poder contar con una historia que era Git y cómo funcionaba. Aquí va la primera entrega de lo que espero sean muchas.\nEste querido amigo nos servirá para monitorear los archivos de un proyecto, y así controlar las versiones y avances.\nLes presento al R2D2-Git y las funciones básicas para tenerlo funcionando en un proyecto.\nGit se ejecuta dentro de la carpeta principal de nuestro proyecto y reconoce TODO lo qué hay dentro.\nEntonces, a partir de ese momento ya no estarás solo en el desarrollo del proyecto, porque Git estará para apoyarte.\nGit verá todos los archivos, pero es necesario indicarle los archivos que deseamos versionar.\nVeamos como ir usando Git poco a poco.\n ESTADO DE LOS ARCHIVOS QUE MONITOREA GIT Primero debemos preguntarle qué ve en nuestro proyecto el pequeño amigo Git, el hablara con la verdad y dirá cada archivo qué hay que no este monitoreando.\n DILE A GIT DONDE PONER EL OJO Una vez que sabemos el estado de aquello que no está monitoreando, podemos indicarle a Git qué archivo debe monitorear, podemos iniciar por uno.\nSi volvemos a pedirle el STATUS, verás que ya no cuenta el archivo agregado.\n AL CONFESIONARIO CON GIT Una vez que Git ya está monitoreando el archivo, habrá que indicarle una descripción corta de qué es el archivo, qué se modificó, etc.\n REPETIR Si agregamos un archivo (ADD) dentro del proyecto, y le damos un COMMIT, entonces estará siendo monitoreado por Git. Es necesario ir agregando cada archivo a Git mediante el ADD-COMMIT.\nUna vez que el STATUS no muestre ningún archivo, tendremos nuestro proyecto versionado bajo la mirada y el monitor de Git.\nSi modificaramos un archivo, automáticamente el STATUS mostrará que hubo un cambio e indicará el archivo, de igual forma lo hará si se añaden nuevos archivos al proyecto.\nEs posible identificar las diferencias existentes en un archivo, bastará con indicarle a git.\nY finalmente aplicaremos el ADD y COMMIT para monitorearlo por Git.\nNotarán que Git irá diciendo que está funcionando sobre algo llamado \u0026ldquo;Master\u0026rdquo;, que es la rama principal, y creada por defecto, que será tema para otra entrega.\nReview Comandos de esta publicación de Git\ngit init //Para iniciar Git en tu proyecto git status //Para ver los archivos no monitoreados git add file.sm //Indicarle a git que contemple un archivo git commit -m \u0026quot;Descripcion\u0026quot; //Indicarle una descripcion del archivo agregado anteriormente git diff file.sm //Git te mostrará las modificaciones  ","permalink":"https://carlogilmar.xyz/es/posts/git_para_principiantes/","title":"Git para Principiantes"},{"content":"Como llegue a Linux Es importante entender que en la vida siempre se puede escoger, y en el caso de la tecnología también. Quizá sea el hecho de que casi cualquier laptop o equipo de escritorio tengan por defecto Windows en sus muchas versiones, la paquetería de Office, el magnífico Paint y el buscaminas; y pareciera que nuestra elección se cierra a una búsqueda en Google que diga \u0026ldquo;programas gratis para Windows\u0026rdquo;. El asunto es que por alguna razón siempre mis equipos terminaban alentándose demasiado, de pronto se congelaba, me pedía actualizaciones, y cada instalación de algún programa era también una preocupación de no saber que virus o banner en el navegador pudiera instalar.\nAsí que algún día escuché sobre un sistema operativo diferente: Linux. Aunque encontré a una que otra persona que usara alguna distribución Linux, no encontré a alguna que únicamente usará Linux en su equipo.\nAsí que frustrado por la lentitud de Windows en mis equipos, decidí emprender una nueva aventura.\nPrimeros pasos Linux Temeroso de haber usado siempre Windows, instale en una partición la distribución Debían 8. La instalación fue sencilla, pero la configuración no. Afortunadamente todo lo podía buscar en Google; y aunque encontraba los pasos que solucionaban mis problemas siempre me dejaba un mal sabor de boca no saber qué demonios hacía con la consola.\nLa principal diferencia que notaba era el rendimiento: mi equipo iniciaba y se apagaba más rápido, abría el navegador con mayor rapidez, y contaba con una paquetería ofimática que aunque era básica contaba con todo lo indispensable.\nMi búsqueda por un mejor rendimiento me llevaba a dar una conclusión: Linux exige saber cómo opera, pero vale la pena.\nPrimeros Rounds Con la camiseta puesta, y decidido por encontrar el SO que mejor me acomodara, instalé Ubuntu en mi equipo.\nLa primera batalla fue la instalación, y para mí se convirtió en el paso de la muerte porque temía dañar mi partición de respaldo, no comprendía porque necesitaba tantas particiones y porque no se instalaba solo.\nEl segundo round fue la configuración que requería instalar Java, y poner al día las famosas variables de entorno\u0026hellip; Pero desde la consola.\nUno más fue la configuración de la impresora, la mía afortunadamente es una HP, pero la solución requería de ejecutar scripts en la consola.\nY otro doloroso: en aquel tiempo usaba un iPhone, y no hay iTunes para ambientes Linux, por lo que me llevó a resucitar a Windows del mundo de los muertos pero en una máquina virtual, otro gran round.\nUn golpe más al hígado: no se reconocen los drivers de todos los componentes como el que maneja el brillo de la pantalla. Esto requería de una buena guía y mucha suerte para que funcionara.\nHallando la luz Sin embargo a pesar de recibir los primeros golpes, poco a poco fui entiendo el ritmo de la batalla:\nPara instalar por ejemplo Chrome ya no tenía que ir a su página, descargar, descomprimir, instalar, siguiente, siguiente, siguiente, aceptar; sino que bastaba con a lo más tres líneas de comandos en la consola para realizarlo, y eso ahorra mucho tiempo.\nEl entorno gráfico que instala Ubuntu por defecto (Unity) era muy pesado para mi equipo, pero para mi sorpresa pude instalar otros entornos mucho más ligeros como Gnome con los que el rendimiento aumentaba.\nConforme fui conociendo un poco más del SO, su sistema de ficheros, la configuración, y el uso de la consola, fui aprendiendo a sacarle mayor provecho.\nAprendí después sobre el uso de las diferentes shell ( zsh, fish, bash) y la gran rapidez que se puede ganar con el uso de la consola con algunas vitaminas como tmux, git y vim, y también a través de scripts.\nDel amor y el desamor Finalmente puedo decir que al día de hoy soy muy feliz con Linux, y he llegado a las siguientes conclusiones:\n  Linux tiene todo lo necesario para vivir bien.\n  Carece aún de ciertas cosas como iTunes y Microsoft Office, lo cual puede ser solucionado con una virtualización.\n  Lo más grave que encontré fue la configuración de los controladores, aunque no es algo que no se pueda solucionar.\n  Los programas similares a la paquetería de Office no son Office y eso crea problemas con la compatibilidad, si escribes algo y lo guardas en formato odt seguramente podrá ser abierto por un Word, pero con una configuración diferente ( letra, paginación, márgenes). La solución: usar Google docs para evitar estos problemas.\n  Y finalmente puedo decir que UN GRAN PODER CONLLEVA UNA GRAN RESPONSABILIDAD. Linux es un SO muy poderoso, que exige conocimiento sobre su funcionamiento: comandos, uso de consola, sistema de archivos, particiones, instalación de programas, variables de entorno, etc. Pero en respuesta Linux ofrece un trabajo muy fluido.\n  Para mí que debía escribir muchos archivos de texto, navegar en internet, para cumplir con las tareas de sociología, pero además que debía instalar compiladores, entornos de desarrollo y editores de texto para programar, Linux me trato bien.\nEso sí, tiene problemas que no son tan sencillos de resolver si eres un usuario normal de Windows, que requieren de un entendimiento más profundo para poder resolverse.\nA final de cuentas llevo 9 meses totalmente migrado a ambientes Linux, y a pesar de los malos ratos puedo decir que todo ha valido la pena.\n","permalink":"https://carlogilmar.xyz/es/posts/prueba/","title":"Cuando abandoné Windows, y llegué a Linux"},{"content":"Hola Mundo\nSeguramente algunos habrán entrado a mi antiguo blog en CarloGilmar.Huelum.com, y pues ahora quedó indispuesto porque hallé a alguien mejor que Wordpress: Hugo.\nPor lo que tome la decisión de migrar el blog totalmente a lo que Hugo podía brindarme, que es más que suficiente para todo aquello que quiero compartir y estaré compartiendo por medio de esta nueva plataforma.\nSaludos, y mil gracias por leer.\n","permalink":"https://carlogilmar.xyz/es/posts/hi/","title":"Adiós Wordpress y Hola Hugo"},{"content":"Recientemente tuve la oportunidad de asistir a la charla de Scrum para Altos Ejecutivos y Directivos en Lymon. Ahora me toca compartir lo que aprendí a mi manera.\nSCRUM es un marco de trabajo ágil, quizá uno de los más populares, sin embargo regularmente es común hallar su ejecución en los equipos de desarrollo, no así en la parte directiva, y muy difícilmente a nivel organizacional. La pregunta más interesante es ¿cómo permear desde la zona operativa la esencia ágil de scrum hasta la parte organizacional?\nEs conveniente recurrir a la perspectiva histórica para entender la importancia de los entornos de trabajo ágil. Relativamente la industria de las tecnologías de la información es un campo que no rebasa más allá del siglo, a diferencia de la industria manufacturera por ejemplo.\nHay grandes diferencias entre los procesos industriales y el desarrollo de software, recordando un poco la película de \u0026ldquo;Tiempos Modernos\u0026rdquo; de Charles Chaplin ilustra muy bien las líneas productivas en el siglo anterior. Este modelo fue hererado para los proyectos de software.\nEsta herencia es mejor conocida como el Modelo en Cascada, mismo que fue adaptado para la elaboración de productos materiales, en su mayoría, y que a través del tiempo fue perfeccionado y heredado desde la academia.\nMientras esta metodología servía muy bien en los procesos de manufactura, ocurría lo contrario en la industria del software, un campo que carece de productos tangibles, y que versa más sobre la creatividad y el trabajo intelectual, para ello fue necesario buscar nuevas formas de crear: los marcos de trabajo ágiles.\nSCRUM es uno de ellos, contiene sus propios artefactos, sus propias ceremonias, y formas de trabajar. Un punto controversial, y también un principio ágil, es la entrega constante de valor, ya que esto suele confundirse con \u0026ldquo;aumento de velocidad en el trabajo de desarrollo\u0026rdquo;. Esto es incorrecto, ya que SCRUM no es una super medicina que alivia todos los males y mejora la condición, desde mi perspectiva es más bien una terapia que toma tiempo y esfuerzo.\nEL ROL DEL DIRECTIVO\nSCRUM se ubica mayormente en la parte táctica de la Planeación Estratégica, mientras la parte estratégica corresponde a los directivos. Esto debido a la versatilidad del modelo para ejecutarse en equipos no muy numerosos. SCRUM entra en la Planeación Estratégica Formal, no es un barco a la deriva.\nRecordando un poco SCRUM tiene tres roles: el equipo, Product Owner, y el Scrum Master. Un directivo, o ejecutivo, puede aportar más a este marco si es ubicado en un rol ya sea el de Stakeholder, o el de Product Owner. Uno de los pilares de Scrum es la inclusión organizacional.\nExisten formas de poder hallar números que nos indiquen el progreso.Un Sprint Backlog puede contener 3 tareas/historias de usuario.Cada tarea/historia de usuario es ponderada con puntos (Story Points).Si al final del sprint, el Product Owner certifica que se han terminado en forma (DONE) lo comprometido del backlog para el sprint, entonces se considera la suma total de los puntos.Se puede cuantificar el número de horas hombre totales que se invirtieron en el sprint, y juntar con el total de puntos completados. Esta relación dará una impresión del ritmo de trabajo del equipo.\nExiste un instrumento muy útil llamado BURNDOWN CHART que es una gráfica que contempla los Story Points totales del proyecto/sprint (eje Y) y los días de trabajo (eje X). Contiene una medición ideal, que es la disminuación paulatina de los puntos hasta llegar a cero en el último día. Y contiene la medición real que no es lineal, sino que varia, esta variación posee una tolerancia a su ajuste a la recta ideal, pero sirve para conocer si el ritmo de trabajo es crítico en alguna etapa del proyecto.Este mismo instrumento puede complementarse al incluir el eje -Y como el trabajo no planificado para conocer cuanto se esta desarrollando durante el sprint, y poder identificar aquello que no se contempló.\nCONCLUSIONES:\nMe queda muy claro que SCRUM es un marco organizacional inclusivo.SCRUM, como las metodologías ágiles, son parte de un proceso de cambio organizacional paulatino.Más que una receta, metodología con pasos exactos a seguir, desde mi perspectiva con oportunidad de errar puedo decir que se trata de una forma de vivir, no es algo limitado al desarrollo.Aunque se usa actualmente para el desarrollo de proyectos de TI, es escalable a otros campos.Esto es: ¡Toma de conciencia de nuestros actos como personas!El modelo SCRUM es versátil. Puede aplicarse en un equipo pequeño y dar resultados, sin que necesariamente se aplique complementente en cada rincón de la organización.Es conveniente incluir al directivo/ejecutivo y ubicarlo en algún rol, de forma que sienta cómo es el ritmo de trabajo y pueda tener participación asertiva.\n","permalink":"https://carlogilmar.xyz/es/posts/scrumcourse/","title":"Scrum Para Altos Directivos"},{"content":"Este śabado tuve la oportunidad de poder participar en el Agile Open 2016 organizado por la comunidad de Ágiles México, pensaba escribir un largo y emotivo texto, pero ya que tengo tiempo libre lo intentare explicar con Facilitación Gráfica, ¡a ver que tal me sale!\nAquí va la primera imagen\u0026hellip; ¿Qué es un Agile Open? ¿Cuáles son los principios básicos y la regla de los dos pies?\n¡Inicia el Agile Open 2016! ¿Quieren saber cómo se organizó la agenda?\nLa primera charla \u0026ldquo;Ser Agile VS Hacer Agile\u0026rdquo;:\nSiguiente charla con @ivanni_simons DESARROLLO CON SCRUM\n¿Alguien no quiere volverse ágil?\n¡Comunidad de Aprendizaje Ágil!\nLiderazgo Ágil\nY el cierre\u0026hellip;\nY aquí van algunas fotografías de Ágiles México\nSin duda alguna un día lleno de pasión, felicidad y motivación.\nMil gracias por leer.\n","permalink":"https://carlogilmar.xyz/es/posts/agileopen/","title":"Mi Primer Agile Open"},{"content":"En una materia de mi carrera me pidieron armar un equipo y pensar en una idea a desarrollar\u0026hellip; la materia es Construcción de Base de Datos.\nComo recientemente estoy introduciéndome al mundo ágil decidí que esta era la oportunidad de empezar a vivir la agilidad. El primer reto era convencer a mis dos compañeros de equipo que aprender Metodologías Ágiles sería una forma super padre de aprender y hacer algo chido. No tuve mayor problema, confiaron en mi.\nEl primer día de clases cuando ya teníamos a los tres integrantes del equipo, la profesora nos pidió entregarle dentro de dos días un cronograma de actividades y el objetivo de nuestro proyecto. Troné. No sabía cómo hacer para planificar una idea desde cero, y entregar un cronograma perfecto, entonces empezamos como equipo a plantear lo que íbamos a realizar.\nPLANEANDO UNA IDEA Al principio ocurrió lo que creo que pasa comúnmente: pensar en términos de tecnología. ¿Qué quieren hacer? \u0026ldquo;hagámos una base de datos en mysql enlazada con java\u0026rdquo; e ideas como esas surgieron, pero consideré que no era lo mejor, así que propusé un cambio de visión a través de pensar en un proyecto como una solución a un problema desde el lenguaje coloquial, las palabras que usamos normalmente, sin terminología tecnológica ni nada de eso. El objetivo era sacar una idea general de una solución a un problema, y aún así saltaron las ideas que siempre he escuchado en la mayoría de mis compañeros upiicsianos: \u0026ldquo;hagámos el inventario de una ferretería, el sistema de ventas de una zapatería, el almacén de una tienda de abarrotes, etc\u0026hellip;\u0026rdquo;.\nBien, esta fue nuestra idea\u0026hellip;\nPROYECTO IPNetwork Objetivo: Mejorar la comunicación entre los compañeros de clase a través de una plataforma donde puedan compartir los aprendizajes de su carrera.\nContexto: Por lo regular los alumnos en una clase escolar realizan varias investigaciones y proyectos, que en la mayoría de las ocasiones son archivados. Creemos que si como alumnos compartiéramos nuestro archivo de conocimiento por medio de una plataforma que permitiera además dar una retroalimentación, podríamos mejorar el proceso de aprendizaje para quien acceda al recurso, como para quien lo facilita.\nUna vez que tuvimos \u0026ldquo;medio\u0026rdquo; clara la idea, debímos pasar a la planeación, una de las cosas que considero más difícultosas.\nNuevas ideas El pasado 15 de Marzo tuve la oportunidad de ir al evento mensual del grupo Ágiles México, sobre Facilitación Gráfica con Fernando Guajardo. Aprendí muchas cosas interesantes.\nUna de ellas es que mediante la expresión gráfica es más facil comunicar ideas por la implicación de los sentidos humanos. No es lo mismo ver una idea representada en un dibujo con colores y formas, que verla escrita en una minuta.\nLo que hicimos en el taller fue primero armar un equipo, y que alguien hiciera muchos rayones. Después entre todos debíamos hallar cosas enmedio de los rayones. Esto fomenta la creatividad.\nLa siguiente actividad fue jugar basta entre todos, el típico juego que todos hemos jugado pero con la particularidad de que ahora con la letra elegida debíamos dibujar la mayor cantidad de objetos. Este fue un buen reto.\nNos dieron una Historia de Usuario, el siguiente reto consistía en dibujarla. Creo que mucho de lo que hicimos y nos explicó Fernando G. aterrizaba aquí. Leer una historia de usuario es diferente a verla.\nAquí comenzó a brincar mi ardilla mental: si dibujas algo, y plasmas tu idea general vas a poder comunicarla mucho mejor, de tal modo que la comunicación es oro, y por medio del dibujo lo haces de una forma muy creativa y fácil de explicar.\n(Cosas del destino: No alcancé registro en el MeetUp porque los lugares volaron como pan caliente, aún así fui esperanzado de entrar y cuando llegue al lugar no me dejaron pasar por no estar en lista. No perdí la fe y me quede cerca del lugar mientras le mandaba un tweet a uno de los organizadores para ver si no habían ido las 100 personas registradas y había algún lugarcito disponible. No contestaba. Ya cuando me íba recibí el tweet de que fuera. Por poquito y no llego.)\nContinuando con el Proyecto\u0026hellip; Para mi planeación decidí usar lo que había aprendido en días anteriores con la facilitación gráfica. He aquí mi planificación como historia:\nEsto fue un dibujo para mí, para saber qué iba a hacer para planear la planeación de mi proyecto junto con mi equipo. Amo las redundancias porque me hacen saber que las cosas no son tan fáciles. Mi tarea era hacer realidad la historia que ya había dibujado: 1.- Ya tenía mi equipo conformado. 2.- Pláticamos sobre los alcances de este proyecto más allá de una materia de la escuela, y concordamos en que si nos apoyabamos podíamos aprender mucho en cuestión técnica, humana, organizacional, y hacer un producto que sirviera para algo.\nY llegamos a la parte de definir el proyecto.\nLes propuse lo siguiente: Dibujar nuestra visión de la solución que íbamos a hacer realidad. Aquí empezaba la alquimia, entonces tomé las plumas de color que tenía a la mano y dibujé lo que quería solucionar: un alumno que tiene un archivo que alguien más puede consult\u0026hellip;bla bla bla.\nMis compañeros quedaron medio en shock, y de inmediato alguien dijo que no estaba de acuerdo con mi visión del proyecto, pero les expliqué que realmente el ejercicio trataba de sumar ideas sobre la visión general e ideal, que no discutieramos, aunque no pensaramos lo mismo, que sólo pusieramos nuestras ideas y erigieramos al mismísimo mounstro de Frankenstein. Esto fue lo que resultó\u0026hellip; Aquí nuestro mounstruo ideal.\nAhora teníamos nuestro mapa general de lo que era nuestro proyecto a realizar con la visión de los tres. Acto seguido pasamos a escribir cada función en una Historia de Usuario; algo así como hacer un rompecabezas de nuestro dibujo, cada partecita es una Historia de usuario.\n(Como no tenemos un lugar en la escuela, puse a mis compañeros en un ventanal de la Upiicsa ja, ja, mientras se nos quedaban viendo con cara de \u0026ldquo;estos cabrones qué chingados hacen\u0026rdquo;)\nEntonces hasta aquí ya teníamos la visión general de lo que íbamos a hacer\u0026hellip; y también ya teníamos las funcionalidades en forma de Historias de Usuario\u0026hellip; ahora faltaba ponderar cada Historia.\nPLANNING POKER En el blog de proyectosagiles.org encontré una entrada a esta metodología para ponderar:\nConsta de un mazo de cartas que deberá tener cada miembro del equipo, un mazo que es una serie fibonacci que puede variar pero va del 0, 1/2, 1, 3, 5, 8, 13, 20, 40, 100, una con un signo de ?, y otra con un infinito.\nEntendí que se debe elegir como será la escala si en horas ideales, tamaño de la tarea, o complejidad. Una vez elegido, se va una por una, cada Historia de Usuario y cada integrante elige la carta con la ponderación que él le da, se pone boca abajo, y se revela cuando todos hayan elegido la suya. Lo que hice aquí fue darle un mazo a cada persona, y decidimos ponderar por importancia, 0 era el menor y 100 el mayor. Pasamos cada historia de usuario, y elegiamos una carta, escribimos la sumatoria de todas las cartas en su historia de usuario y así sucesivamente. Al final obtuvimos las historias de usuario ya ponderadas por nivel de importancia. Surgió algo interesante, mientras para mi una función valía 5, para mis compañeros valía 100; mientras para mí y para otro colega valía 100, para nuestra compañera valía 0, o al revés cuando a dos de nosotros le dábamos 1, alguien le daba 100. Para eso entendí que era el Planning Poker, es decir, para llegar efectivamente al consenso.\nUna vez que tuvimos nuestras Historias de Usuario hechas y ponderadas. Decidimos cuáles íbamos a hacer para nuestro primer demo y así llegamos a nuestro Backlog que después capture en Trello ¡Ay que felicidad implementar todo lo que he aprendido!\nY hasta aquí mi reporte joaquín\u0026hellip; Algunas notas mentales\u0026hellip;\nPor supuesto que mentímos con el cronograma que habíamos entregado a la maestra. Mis colegas al principio estaban medio escépticos con lo que les mostraba, pero al final me agradecieron el aprendizaje que les compartí y concluyeron que esta forma estuvo super fácil para hacer la planeación. Y yo estoy super feliz de haber compartido lo que estuve aprendiendo\u0026hellip; \u0026quot; nada para mí que no sea para los demás\u0026quot;\nGracias por leer, Carlo.\n","permalink":"https://carlogilmar.xyz/es/posts/proyectoagil/","title":"Mi Primer Proyecto Ágil"},{"content":"Este es mi primer contenido en este blog para compartir mis experiencias como desarrollador de software.\nAquí comparto una ponencia que prensenté el año pasado en Upiicsa, con apoyo de tres profesores que me cederieron sus clases, sobre el uso del Software Libre y algunas de sus bondades que podríamos usar.\nDudas, aclaraciones, comentarios también en carlogilmar12@gmail.com.\nhttp://www.slideshare.net/karlogilmar1/ponencia-para-ipn-upiicsa\n","permalink":"https://carlogilmar.xyz/es/posts/exposwlibre/","title":"Ponencia de Software Libre para UPIICSA"}]